# CHAPTER 3



## 01. 연산자와 피연산자

연산자는  `연산을 수행하는 기호` 이다. 연산자가 연산을 수행하려면 연산의 대상이 있어야 하는데 이것을 `피연산자(Operand)` 라고 한다. 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것은 `식`, 이 식을 계산하여 결과를 얻는 것을 `식을 평가(evaluation)` 이라고 한다.

> x + 3  
>
> - x + 3 	=> 식
>
> - x, 3       => 피연산자
> -   +         => 연산자 



```java
4 * X + 3
  > 4 * 5 + 3
  > 23
```

> 식이 평가되어 23이란 결과를 얻었지만 이 값은 어디에도 쓰지 않고 사라지기 때문에 대입 연산자( = ) 를 사용해 변수와 같이 값을 저장할 수 있는 공간에 저장함.



````java
y = 4 * x + 3;					// x의 값이 5라면, y의 값은 23이 된다
System.out.println(y);	// y의 값인 23이 출력
````

> 변수 y에 값이 저장되어 다른 곳에 사용할 수 있다. 유의미함. 만일 식의 평가결과를 출력만 하고 싶다면 println() 메서드에 직접 식을 써도 된다.
>
> > ```` java
> > System.out.println( 4 * x + 3); // x = 5 라고 가정
> > 	> System.out.println(23);
> > ````





## 02. 연산자의 종류

### 연산자의 종류

|    종류     |          연산자           | 설명                                          |
| :---------: | :-----------------------: | --------------------------------------------- |
| 산술 연산자 |   +  -  *  /  %  <<  >>   | 사칙 연산과 나머지 연산(%)                    |
| 비교 연산자 |    >  <  >= <=  ==  !=    | 크고 작음과 같고 다름을 비교                  |
| 논리 연산자 | &&   \|\|  !  &  \|  ^  ~ | AND 와 OR으로 조건을 연결                     |
| 대입 연산자 |             =             | 우변 값을 좌변에 저장                         |
|    기타     | (type)  ?  :  instanceof  | 형변환 연산자. 삼항 연산자. instanceof 연산자 |

> 피연산자의 개수로 연산자를 분류하기도 한다.
>
> - 단항 연산자 : 피연산자의 개수가 한 개
> - 이항 연산자 : 피연산자의 개수가 두 개 (대부분의 연산자)
> - 삼항 연산자 : 피연산자의 개수가 세 개





## 03.  연산자의 우선순위

| 식                       | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| -x   +   3               | 우선순위 : 단항 연산자 > 이항 연산자 <br/>x의 부호를 바꾼 다음 덧셈이 수행 됨 |
| x  +  3  *  y            | 우선순위 : 곱셈과 나눗셈 > 덧셈과 뺄셈<br/>3 * 7 이 먼저 계산 됨 |
| x  +  3   >  y   -  2    | 우선순위 : 산술연산자 (+), (-)   > 비교 연산자 (>)<br/>'x + 3' 과 'y - 2'가 먼저 계산 된 다음 '>' 가 수행 |
| x  >  3  &&  x  <  5     | 우선순위 : 비교 연산자 > 논리 연산자(&&)<br/>'x > 3' 와 'x < 5' 먼저 계산 후 '&&' 수행 |
| result  =  x  +  y  *  3 | 대입 연산자는 연산자 중 우선순위가 가장 낮다.<br/>우변의 최종 연산 결과가 변수 result에 저장된다 |





## 04. 연산자의 결합규칙

하나의 식에 우선순위 연산자가 여러개 있을 경우, `연산자의 결합규칙` 에 따라 처리한다.

> 1. 산술 > 비교 > 논리 > 대입 연산자 순으로 대입 연산자는 가장 마지막에 수행된다.
> 2. 단항 (1) > 이항 (2) > 삼항 (3) 순. 단항 연산자의 순위가 이항 연산자보다 높다.
> 3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행 방향은 왼쪽에서 오른쪽이다.

```` java
Public static void main(String [] args){
  int x, y;
  
  x = y = 3;  											// y = 3 다음으로 x = 3 
  System.out.println("x = " + x);		// x = 3
    System.out.println("Y = " + y);	// y = 3
}
````





## 05. 증감 연산자 ++ 과 --

증감 연산자는 피연산자에 저장된 값을 1 증가 또는 감소 시킨다. 정수와 실수는 가능하지만, 상수는 값을 변경 할 수 없으므로 불가능하다.

> 증감 연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않음. 연산결과의 타입은 피연산자 타입과 동일함.



| 타입                                       | 설명                                    | 사용 예  |
| ------------------------------------------ | --------------------------------------- | -------- |
| 전위형 (Prefix, 피연산자의 왼쪽에 위치)    | 값이 참조되기 **전에** 증가/감소 시킨다 | j = ++i; |
| 후위형 (Postfix, 피연산자의 오른쪽에 위치) | 값이 참조된 **후에** 증가/감소 시킨다   | j = i++; |

> 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다.
>
> >  ++i ;	// 전위형. i 의 값이 1 증가한다
> >
> > i++; 	// 후위형. 위의 문장과 차이가 없다



````java
public static void main(String args[]) {
 int i = 5, j = 0;
  
  j = i ++;
  System.out.println("j = i++ 실행 후 , i = " + i + ", j =" + j);
  //  j = i++ 실행 후 , i = 6, j = 5
  
  i = 5;
  j = 0;			// 결과 비교를 위해 i와 j의 값을 5, 0 으로 변경
  
  j = ++i;
  System.out.println("j = ++i 실행 후 , i = " + i + ", j =" + j);
  //  j = ++i 실행 후 , i = 6, j = 6
}
````

> 전위형(++i)은 변수의 값을 먼저 증가 시킨 후 변수 값을 읽어온다.
>
> 후위형(i++)은 변수의 값을 먼저 읽어온 후, 변수 값을 증가 시킨다.





## 06. 부호 연산자

부호 연산자 ' - ' 는 피연산자의 부호를 반대로 변경한 결과를 반환한다. 부호 연산자는 boolean 형과 char 형을 제외한 기본형에만 사용 가능.

- 피연산자가 음수 -> 연산 결과가 양수
- 피연산자가 양수 -> 연산 결과가 음수

````java
public static void main(String args[]) {
  int i = -10;
  i = +i;
  System.out.println(i);		// -10
  
  i = -10;
  i = -i;
  System.out.println(i);		// 10
}
````





## 07. 형변환 연산자(Casting)

서로 다른 타입 간의 연산은, 수행하기 전 타입을 일치 시켜야 하는데 변수나 리터럴을 다른 타입으로 변환하는 것을 `형변환(casting)` 이라고 한다. 방법은 변수나 리터럴 앞에 변환하고자 하는 타입을 괄호와 함께 붙여준다.

> 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환 하는 것.
>
> 괄호() 는 캐스트 연산자, 형변환 연산자라고도 한다.
>
> ​	->  (타입)피연산자



````java
public static void main(String args[]) {
  double d = 85.4;
  int score = (int)d;
  // int score = (int)d;  -> int score = (int)85.4;  ->  int score = 85;
}
````



#### 형변환의 다양한 예시

|      변 환      |    수 식     | 결 과 |
| :-------------: | :----------: | :---: |
|  int  ->  char  | ( char ) 65  |  'A'  |
|  char  ->  int  | ( int ) 'A'  |  65   |
| float  ->  char | ( int ) 1.6f |   1   |
| int  ->  float  | ( float ) 10 | 10.0f |

> 형변환 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과만 반환함.
>
>  -> 피연산자 값은 형변환 후에도 아무런 변화가 없다.







## 08. 자동 형변환

경우에 따라, 편의상의 이유로 형변환 생략 가능. -> 컴파일러가 생략된 형변환을 자동적으로 추가하며, 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 된다.

```` java
float f = 1234;			// float f = (float)1234; 에서 (float) 가 생략됨
````

>위 문장에서 우변은  int 타입의 상수이고,  이 값을 저장하려는 변수는 float 이지만 float 타입의 변수는 정수 1234를 저장하는데 아무 문제가 없기 때문에 형변환을 생략하였다.



```` java
byte b = 1000;			// 불가능. byte 타입의 범위 (-128 ~ 127) 을 벗어난 값 대입
````

>변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 변환을 생략하면 에러가 발생한다.



```` java
byte b = (byte)1000;	// 가능. 그러나 값의 손실이 발생해서 변수 b 에는 -24가 저장된다.
````



#### 형변환이 가능한 기본형

> 1byte    2byte     4byte     8byte   4byte    8byte
>
> byte  ➝ short ➝   int   ➝ long ➝ float ➝ double
>
> ​                  char ↗︎
>
> ----------------------------------
>
> 화살표 방향으로 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 된다.
>
> 반대의 경우는 반드시 형변환 연산자를 사용해야 한다.







## 09. 사칙 연산자

피연산자가 정수형일 경우, 나누는 수로 0을 사용할 수 없다. 

``` java
public static void main(String args[]) {
	int a = 10;
  int b = 4;
  
  System.out.printf("%d + %d = %d%n", a, b, a + b); // 10 + 4 = 14 
  System.out.printf("%d - %d = %d%n", a, b, a - b); // 10 - 4 = 6
  System.out.printf("%d * %d = %d%n", a, b, a * b); // 10 * 4 = 40
  System.out.printf("%d / %d = %d%n", a, b, a / b); // 10 / 4 = 2
  System.out.printf("%d / %f = %d%n", a, (float)b, a / (float)b); // 10 /4.000000 = 2.5000000
}
```

> 10 / 4 = 2
>
> - int / int = int 
> - 나누기 연산자의 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int타입이다. 실제 연산결과가 2.5 이더라도 정수만 남고 소수점 이하는 버려지기 때문에 2가 출력된다.
> - 반올림이 발생하지 않는다.





## 10. 산술 변환

#### 산술변환이란? 

- 이항 연산자의 두 피연산자는 타입이 일치해야 연산이 가능하다. 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야 한다. (= 연산 직전에 발생하는 자동 형변환)

- 단항 연산에서도 일어난다.

  >두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
  >
  >> long     + int     -> long     + long       -> long
  >>
  >> float.    + int     -> float     + float      -> float
  >>
  >> double + float -> double + double ->double
  >
  >
  >
  >피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
  >
  >> byte + short -> int + int -> int
  >>
  >> char + short -> int + int -> int





## 11. Math.round()로 반올림하기 

Math.round() 

- 소수점 첫째 자리에서 반올림한 결과를 정수로 반환한다.

```` java
long result = Math.round(4.52); // result에 5가 저장된다
````

- 첫째 자리가 아닌 다른 자리에서 반올림 하려면 10의 n 제곱으로 곱하고 나눠야 한다.

```` java
public static void main(String args[]) {
  double pi = 3.141592;
  double shortPi = Math.round(pi * 1000) / 1000.0;
  // (3.141592 * 1000) / 1000.0
  //  > 3141.592 / 1000.0
  //  > 3141 / 1000.0
  System.out.println(shortPi); // 3.142
}
````





## 12. 나머지 연산자

같은 값이라도 다른 형식으로 출력하고 싶을 때 사용한다. (println은 변수의 값을 그대로 출력 -> 변환하지 않고 다른 형식으로 출력할 수 없음)

```` java
public static void main(String args[]) {
	int age = 14;
  int year = 2020;
  
  System.out.printf("age : %d", age);
  > System.out.printf("age : %d", 14);
  > System.out.printf("age : 14");  // "age : 14" 가 출력된다
  
  System.out.printf("age : %d year : %d", age, year);
  > System.out.printf("age : %d year : %d", 14, 2020); // "age : 14 year : 2020" 이 출력된다
}
````

> 출력하려는 값이 2개 이상일 경우에는 지시자도 그만큼 증가하며, 개수의 제한은 없다.
>
> 출력될 값과 지시자의 순서는 일치해야 한다.
>
> println()과 달리 printf()는 출력 후 줄바꿈을 하지 않는다. 지시자 '**%n**' 을 따로 넣어줘야 한다



| 지시자             | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| %d                 | 10진(**d**ecimal)정수의 형식으로 출력                        |
| %x                 | 16진(he**x**a-decimal)정수의 형식으로 출력                   |
| %f <br/>(실수표현) | 부동 소수점(**f**loating-point)의 형식으로 출력 ->  기본적으로 소수점 아래 6자리 까지만 출력 됨. (이게 넘어갈 경우 반올림 |
| %c                 | 문자(**c**haracter)로 출력                                   |
| %s                 | 문자열(**s**tring)로 출력                                    |

- 실수형 값 출력 지시자

| %f     | 주로 사용되는 지시자 |
| ------ | -------------------- |
| **%e** | 지수 형태로 출력     |
| **%g** | 값을 간략하게 표현   |

> 전체 자리수와 소수점 아래의 자리수를 지정할 수도 있다. 
>
> EX ) System.out.printf("d = %14.10f%n", d);       // 전체 14자리 중 소수점 아래 10자리
>
> ​												%전체자리.소수점아래자리f
>
>  												여기서 소수점 아래의 빈자리는 0으로 채운다.

```java
public static void main(String[] args){
  String url = "www.codechobo.com";
  float f1 = .10f;                        // 0.10, 1.0e-1
  float f2 = 1e1f;                        // 10.0, 1.0e1, 1.0e+1
  float f3 = 3.14e3f;
  double d = 1.23456789;

  System.out.printif("f1 = %f, %e, %g%n", f1, f1, f1);
  System.out.printif("f2 = %f, %e, %g%n", f2, f2, f2);
  System.out.printif("f3 = %f, %e, %g%n", f3, f3, f3);
  System.out.printif("d = %f%n, d");
  System.out.printif("d = %14.10f%n, d");  // 전체 14자리 중 소수점 10자리 까지
  System.out.printif("[12345678901234567890]%n");
  System.out.printif("[%s]%n", url);
  System.out.printif("[%20s]%n", url);
  System.out.printif("[%-20]%n", url);   // 왼쪽 정렬
  System.out.printif("[%8s]%n", url);    // 왼쪽에서 8글자만 출력
  
  
  /**
  * f1 = 0.100000, 1.000000e-01, 0.100000
  * f2 = 10.000000, 1.000000e+01, 10.0000
  * f3 = 3140.000000, 3.140000e+03, 3140.00
  * d = 1.2345678 <- 마지막 자리 반올림
  * [12345678901234567890]
  * [www.codechobo.com]
  * [   www.codechobo.com]
  * [www.codechobo.com   ]
  * [www.code]
  */
}
```

>지시자 '%s' 에도 숫자를 추가하면 원하는 만큼 출력 공간을 확보하거나 문자열의 일부만 출력할 수 있다.  
>
>- 지정된 숫자보다 문자열의 길이가 작으면 빈자리는 공백으로 출력된다.
>  - System.out.printf("[%s]%n", url);		// 문자열의 길이만큼이나 출력공간 확보
>
>  
>
>- 공백이 있는 경우 기본적으로 우측 끝에 문자열을 붙인다.
>  - System.out.printf("[%20s]%n", url);   // 최소 20글자 출력공간 확보 (우측정렬)
>
>
>
>- ' - ' 를 붙이면 좌측 끝에 붙인다.
>
>  - System.out.printf("[%-20s]%n", url);  // 최소 20글자 출력공간 확보 (좌측정렬)
>
>  
>
>- ' . ' 을 붙이면 문자읠 일부만 출력할 수 있다.
>
>  - System.out.printf("[%.8s]%n", url);    // 왼쪽에서부터 8글자만 출력





## 13. 비교 연산자

```` java
import java.util.Scanner; 						// Scanner 클래스를 사용하기 위해 추가
Scanner sc = new Scanner(System.in);  // Scanner 클래스의 객체 생성

String input = sc.nextLine(); 				// 입력받은 내용을 input에 저장
int num = Interger.parseInt(input);		// 입력받은 내용을 int타입의 값으로 변경

int num = sc.nextInt(); 							// 정수를 입력받아 num에 저장
````

> - nextLine() 이라는 메서드는 입력 후 엔터(Enter) 를 누르면 입력한 내용이 문자열로 반환된다.
>
> - nextInt() 외에도 nextFloat() 도 변환없이 바로 숫자를 입력받을 수 있다.
>   - 입력내용에 문자 또는 공백, 기호가 있으면 오류 발생



## 14. 문자열의 비교 

- 두 문자열을 비교할 땐 비교 연산자 (==)  대신 'equals()' 라는 메서드를 사용한다.

> equals()
>
> - 비교하는 두 문자열이 같으면 true
> - 다르면 false 를 반환 

```` java
String str = new String("abc"); // == String str = "abc";    // String 만 new를 사용해 객체를 생성하지 않아도 허용

//equals() 메서드 사용
boolean result = str.equals("abc"); // 내용이 같으므로 result 에는 true가 저장됨

````



- 문자열이 아닌 대소문자 비교 시, equaisIgnoreCase() 사용

``` java
String str1 = "abc";
String str2 = new String ("abc");

System.out.printf("str2.equalsIgnoreCase(\"ABC\") ? %b%n", str2.equalsIgnoreCase("ABC"));
// str2.equalsIgnoreCase("ABC") ? true
```







## 15. 논리 연산자 && || !

논리 연산자 : 둘 이상의 조건을 '그리고(AND)' 나 '또는(OR)' 으로 연결하여 하나의 식으로 표현할 수 있게 한다.

AND 

- 두 피연산자 모두 true일 때만 true를 결과로 얻는다.

OR

- 두 피연산자 중 어느 한쪽만 true이어도 true결과를 얻는다.

| AND    | OR   |
| :----- | :--- |
| 그리고 | 또는 |
| &&     | \|\| |

| X     | Y     | X \|\| Y | X && Y |
| ----- | ----- | -------- | ------ |
| True  | True  | True     | True   |
| True  | False | True     | False  |
| False | True  | True     | False  |
| False | False | False    | False  |

> ***논리 연산자의 주의점***
>
> > 1. x는 10보다 크고, 20보다 작다.
> >
> > ```` java
> > x > 10 && x < 20 // x  > 10   x < 20  => '그리고(and)' 로 연결된 조건
> > 10 < x && x < 20 // 보통 변수를 왼쪽에 쓰지만 가독성측면에서 나을 수 있음
> > ````
> >
> > 
> >
> > 2. i는 2의 배수 또는 3의 배수이다.
> >    - 어떤 수를 2로 나누었을 때 나머지가 0인 연산 결과를 확인해야 한다.
> >
> > ```` java
> > i % 2 == 0 //ㄷ '또는' 으로 두 조건이 연결 되었으므로 논리 연산자 사용
> >  > i % 2 == 0 || i % 3 == 0
> >  > 8 % 2 == 0 || 8 % 3 == 0
> >  >     0 == 0 || 2 == 0
> >  >       true || false
> >  >           true
> > ````
> >
> > 
> >
> > 3. i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
> >
> > ```` java
> > ( 1 % 2 == 0 || i % 3 == 0) && i % 6 != 0  // '&&' 가 '||' 보다 우선 순위가 높다
> > ````
> >
> > 
> >
> > 4. 문자 ch는 숫자 ('0' ~ '9') dlek.
> >
> > ```` java
> > '0' <= ch && ch <= '9'
> >   // 유니코드에서 문자 '0' 부터 '9'까지 연속적으로 배치되어 있기에 가능한 식
> > ````
> >
> > > | 문자         | '0'    | '1'    | '2'    | '3'    | '4'    | '5'    | '6'    | '7'    | '8'    | '9'    |
> > > | ------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
> > > | **문자코드** | **48** | **49** | **50** | **51** | **52** | **53** | **54** | **55** | **56** | **57** |
> >
> > 
> >
> > 5. 문자  ch 는 대문자 또는 소문자 이다
> >
> > ```` java
> > ('a' <= ch && ch <= 'Z') || ('A' <= ch && ch <= 'Z') 
> > ````
> >
> > 





## 16. 논리 부정 연산자

피연산자가 ture면 false 를, false 일 땐 true를 결과로 반환한다.

| x     | !x    |
| ----- | ----- |
| true  | false |
| false | true  |

> 이러한 성질을 이용하면 한 번 누르면 켜지고, 다시 한 번 꺼지는 TV의 전원버튼과 같은  toggle button 을  논리적으로 구현 할 수 있다.
>
> > ex. 문자 ch는 소문자가 아니다
> >
> > ```` java
> > //ch  < 'a' || ch > 'z'
> > !('a'  <= ch && ch <= 'z')
> > ````





## 17. 조건 연산자

조건식 , 식 1, 식 2 모두 세개의 피연산자를 필요로 하는 삼항 연산자이다. 삼항 연사자는 조건 연산자 하나 뿐이다

![삼항연산자](https://blog.kakaocdn.net/dn/nTxCz/btqzHUfb22b/v45r2ergTPLM6EjFiAWKj0/img.jpg)

```` java
result = (x > y) ? x : y ; // 괄호 생략 가능
````

> x > y 의 결과가 true 면 변수 result 에는 x값이, false 면 y 값이 대입 된다.



- 조건 연산자는 조건 문인 if 문으로 바꿔 쓸 수 있다. (if 문 대신 조건 연산자를 사용하면 코드를 간단히 할 수 있다는 의미)

  ```` java
  if(x > y){
    result = x; // x > y 가 true일 때
  }else {
    result = y; // x > y 가 false 일 때 
  }
  
  result = (x > y) ? x : y ; 
  ````

  



## 18. 대입 연산자

대입 연산자는 변수와 가은 저장공간에 값 또는 수식의 연산결과를 저장하는 데 사용된다.

- 오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장 -> 저장된 값을 연산결과로 반환

```` java
System.out.println( x = 3 );  // 변수 x 에 3 대입
	> System.out.println( 3 );  // 연산결과 3을 출력
````

- 대입 연산자는 연산자 중 순위가 가장 낮아서 나중에 수행 된다.

```` java 
x = y = 3
// 1. y = 3
// 2. x = 3
// 3. 3
````



#### lvalue 와 rvalue

대입 연산자의 왼쪽 피연산자를 `'lvalue(left value)'`, 오른족 피연산자를   ` 'rvalue(right value)'` 라고 한다

- rvalue는 변수와 식, 상수 등 모두 가능함
- lvalue는 반드시 변수처럼 값을 변경할 수 있는 것. (리터럴이나 상수는 lvalue가 될 수 없음)





## 19. 복합 대입 연산자

대입 연산자는 다른 연산자(op)와 결합하여  `'op = '`와 같은 방식으로 사용가능함.

```` java
i = 1 + 3    ====>     i += 3
````

| op =         | =                |
| ------------ | ---------------- |
| i += 3       | i = i + 3        |
| i -= 3       | i = i - 3        |
| i *= 3       | i = i * 3        |
| i /= 3       | i = i / 3        |
| i %= 3       | i = i % 3        |
| i >>= 3      | i = i >> 3       |
| i &= 3       | i = i  & 3       |
| i ^= 3       | i = i ^ 3        |
| i \|= 3      | i = i \| 3       |
| i *= 10 + j; | i = i * (10 +j); |

