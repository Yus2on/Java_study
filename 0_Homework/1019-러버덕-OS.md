# OS 및 일반적인 지식

### OS를 배우는 이유

- 보안과 필수적인 연결성 존재
- 다양한 스마트 디바이스들이 존재하고, 기업이 제공하는 플랫폼 위에서 다양한 어플리케이션을 개발하므로 OS의 기본 이해 필요

<br><br>

### OS(Operating System; 운영체제)

- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 CPU, RAM, Hard Disk를 컨트롤 하는 시스템 소프트웨어의 일종
- 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경 제공 ( = 사용자의 편리성 도모)
- 대표적인 운영체제로 Windows, Linux, Mac OSX, iOS 등이 존재





![운영체제](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F999D32335C4D41EB2DC5EE)





<br><br>

## 터미널(Terminal)

- 키보드와 모니터 등으로 이루어진 **단말기**

- 주로 명령줄 모드(CLI,Command Line Interface)를 나타내는 말. 텍스트 기반 명령을 입력하고 실행할 수 있는 인터페이스

- 기술적으론 다른 의미지만 **Terminal, Console, Shell, Command Line** 으로 불리기도 한다.

  - 콘솔(console)

  - 커맨드 라인(명령줄, command Line) : 명령을 입력하는 모든 것

  - 쉘(shell) : 명령 실행을위한 응용 프로그램. 터미널은 쉘을 실행시키는 프로그램으로, Bash와 ZShell을 실행시킬 수 있다

    ![shell](https://i.stack.imgur.com/OxQZi.gif)



### 참고자료

> - [What is the difference between Terminal, Console, Shell, and Command Line?](https://askubuntu.com/questions/506510/what-is-the-difference-between-terminal-console-shell-and-command-line)



<br><br>



#### CLI / TUI / GUI

- CLI (Command Line Interface)
  - 가상 터미널을 통해 사용자와 컴퓨터가 문자열의 형태로 입력 출력을 주고받는 형태의 인터페이스. ( = 명령줄 인터페이스)
  - 서버 관리 및 프로그래밍 분야에서는 주로 사용. GUI에 비해 상대적으로 자원을 적게 소모하고, 보다 안정적
  - 도스, 명령 프롬프트, 유닉스 쉘 등
- TUI (Text-based User Interface)
  - 문자를 의미 표현 뿐 아니라 레이아웃 표현에도 사용
  - 완전한 화면 영역을 사용하며, 줄단위 출력을 꼭 제공하지는 않는다.
- GUI (graphical user interface)
  - 사용자의 편의성을 위해 입출력 등의 기능을 아이콘이나 그래픽으로 표시
  - CUI에 비해 직관적인 조작이 가능 
  - 컴퓨터를 외에도 MP3 플레이어 등, 포터블 미디어 플레이어, 게이밍 장치, 스마트폰, 소형 가전 등 수많은 휴대용 모바일 장치에 사용

<br><br>



#### 터미널 환경

- 대부분의 백앤드 시스템이 리눅스 기반의 서버에서 운영되기 때문에 리눅스 서버에 접속해서 작업을 할때 텍스트 터미널을 통해 작업을 하는 경우가 많음
- Windows 사용자들이 접하게 되는 CMD 창과 Mac OS 사용자들이 접하게 되는 Terminal 이 CLI  제공 응용 프로그램. 크게 `입력` 과 `출력` 의 단위로 구성.
  - Windows에서는 ‘>’ 형태로, Mac OS, Linux 등에서는 ‘$’ 표시로 사용자의 명령을 기다리는 Command Prompt(명령 프롬프트)가 존재한다. 사용자는 이 부분에 명령어를 **입력** 한다.
  - 사용자가 특정 명령어를 통해 **입력** 을 하게되면(보통 엔터키를 입력하여 명령을 종료), 셸 프로그램이 입력 받은 명령어를 해석하고 명령에 해당하는 적절한 내용을 터미널에 **출력** 해준다.     

<br><br>

#### 자주 사용되는 명령어

운영체제와 상관없이 공통적으로 자주 사용되어 익히고 있어야 하는 명령어가 있다.



1. `ls`：지정한 파일 또는 디렉토리를 표시한다

   - Mac OS, Linux 등 bash(Bourne-Again Shell) 프로그램을 사용하는 터미널은 `ls` 명령어 사용

     ```bash
     # Mac OS, Linux, ...
     
     $ ls
     $ ls -a # 숨김파일까지 확인 가능
     $ ls -la # 상세보기 la 만 사용 가능
     ```

   - Windows 등 DOS(Disk Operating System) 기반 명령 프롬프트를 사용하는 커맨드는 `dir` 명령어 사용

     ```powershell
     # Windosws ...
     
     > dir
     ```

- `cd`：Change Directory 의 약자. 다른 디렉토리로 이동.

  ```shell
  # 공통 명령어
  
  $ cd <현재 디렉토리의 폴더 이름>  # 그 폴더로 이동
  $ cd <디렉토리>               # 특정 디렉토리로 이동
  $ cd ../                    # 상위 디렉토리로 이동
  $ cd ~                      # 루트 디렉토리로 이동
  ```

- `sudo`： superuser do. 현재 계정(일반 사용자)에서 **root 권한을 이용하여 명령어를 실행**할 때 사용. 

  ```shell
  # 공통 명령어
  # sudo 다음에 실행할 명령을 입렵하면 root 권한으로 명령어를 실행
  
  $ sudo apt-get update
  ```

- `pwd`：print working directory 의 약자. 공통 명령어. 현재 작업 중인 디렉토리의 절대 경로를 출력, 내 위치가 궁금할때 사용함.

  ![pwd 명령어](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2440974956E3FA26208130)

- `mkdir`：make directory의 약어로서 새로운 디렉토리를 만들때 사용

  

  ```SHELL
  # 공통 명령어
  
  $ mkdir [옵션] 생성할 디렉토리 이름
  
  $ mkdir linux # 현재 경로에 linux 라는 디렉토리 생성
  $ mkdir -p girls/tiffiny # 상위 디렉토리 경로를 포함하는 디렉토리 생성
  
  ```

- `rm`： Remove의 약자. 일반적으로 하나 이상의 파일을 삭제할 때 사용하며 옵션 값을 입력하면 디렉토리도 삭제가 가능.

  ```SHELL
  # 공통 명령어
  
  $ rm [옵션] 파일명/디렉토리명
  
  $ rm -f test.txt # test.txt 라는 파일을 삭제 여부 묻지 않고 강제 삭제
  ```

<br><br><br>

## 메모리 (Memory)

데이터를 기록하거나 읽기 위한 **저장공간**, 크게 램(RAM : Random Access Memory)과 롬(ROM : Read Only Memory)으로 분류

<br><br>

#### 메모리의 종류

- 메모리는 크게 휘발성이냐 비휘발성이냐에 따라 `RAM(Random Access Memory)` 와 `ROM(Read Only Memory)` 로 분류
- RAM은 **휘발성 메모리**로 전원이 끊기면 데이터가 사라진다. 주로 **PC의 기억장치나 자료의 임시저장소에 사용**
- ROM은 **비휘발성 메모리**로 전원이 끊겨도 데이터가 사라지지 않으며 대표적으로 메인보드에 달려있는 Bios ROM 이 존재



![메모리의 종류](https://t1.daumcdn.net/cfile/tistory/234C194252DE018213)

출처 [삼성반도체이야기 - 메모리 반도체](https://www.samsungsemiconstory.com/300)

<br><br>



### RAM (Random access memory)

- 데이터를 저장하거나 저장된 데이터를 읽어내는 `기억 장치`

- 시스템의 단기 데이터 스토리지로, 정보에 빠르게 액세스할 수 있도록 컴퓨터가 실시간으로 사용하는 정보 저장하고, 저장된 데이터를 순차적이 아닌 임의의 순서로 액세스

- 하드디스크(hard disk)에 보관된 정보는 전원이 꺼져도 사라지지 않고 보관되지만, 휘발성 메모리인 RAM 에 올라간 정보는 전원이 꺼지면 사라짐

- 시스템에서 많은 프로그램을 실행할수록 더 많은 메모리 필요

- SDRAM, RDRAM, DDR SDRAM 등이 있지만, 현재는 DDR SDRAM 종류만 사용

  - DDR 메모리(Double Data Rate Synchronous Dynamic Random Access Memory, DDR SDRAM). DDR1, DDR2, DDR3, DDR4로 분류되며 현재 대부분 DDR3 SDRAM을 지원.

    ![DDR3 SDRAM, samsung.com](http://library.gabia.com/wp-content/uploads/2016/03/DDR3-SDRAM-1.jpg)



#### RAM의 용도

- 컴퓨터가 애플리케이션 로딩, 인터넷 브라우징, 스프레드시트 편집, 최신 게임 플레이와 같은 일상적인 여러 작업을 수행할 때 사용
- 한 작업에서 다른 작업으로 전환할 때 이전 작업의 마지막 위치를 기억하여 이러한 작업을 빠르게 전환하는 데도 필요함

>  사용자가 pc 에서 엑셀을 실행시켰을 때 
>
>  하드웨어 엑셀 실행 -> RAM에 엑셀리을 올림 -> 내용 저장은 하드웨어 -> 엑셀의 연산은 CPU 

<br><br>



### ROM (Read Only Memory)

크게 데이터를 기록하는  `mask ROM` 과 유저가 데이터를 기록할 수 있는   `PROM(Programmable ROM)` 으로 나뉜다.

- PROM 은 다시 OTP, EPROM, EEPROM 등으로 나뉨
  - **MASK ROM** : 가장 기본적인 ROM. 제조사가 ROM 제조시에 데이터를 미리 저장 -> 저장된 데이터는 변경 불가능
  - **PROM (Programmable ROM)** : 저장된 데이터를 지우고 1회 수정할 수 있는 ROM. 모든 저장공간에 퓨즈가 연결되어있으며, 데이터를 기록할 경우 퓨즈가 끊겨 데이터 수정 불가능
  - **EPROM (Erasable PROM)** : 메모리에 저장된 데이터를 지우고, 다시 저장할 수 있는 ROM. 데이터를 지우는 방식에 따라 UVEPROM과 EEPROM으로 분류
    - **UVEPROM (Ultra-Violet EPROM)** : 자외선 사용하여 저장된 데이터를 지울 수 있는 ROM
    - **EEPROM (Electrically Erasable PROM)** : 전기적인 기능을 통해 저장된 데이터를 지울 수 있는 ROM. 정격전압보다 높은 고전앞을 통해 데이터를 지울 수 있으며, 1바이트씩 데이터를 지우기 때문에 속도가 매우 느림



<br><br>

### 플래시 메모리 (Flash Memory)

- EEPROM의 한 종류. 기존 PROM 종류보다 빠르게 기록과 삭제가 가능. 
  - 구조에 따라 NOR / NAND형 메모리로 분류 
  - NOR : 데이터 유지에 있어 오류가 적지만 지우기 속도가 느려 고속화 적용 X
  - NAND : 소형 -> 대용량화 가능 -> 휴대기기에 주 사용
- RAM 처럼 읽고 쓰기가 쉬우면서 ROM처럼 비휘발성 메모리라는 장점이 있음





<br><br>

### 가상 메모리(virtual memory)

- 가상 기억 장치 (virtual storage). 메모리 관리 기법 중 하나.
- 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기에 한계가 있기 때문에 운영체제에서 디스크 공간을 메모리처럼 활용할 수 있도록 기능 제공
  - 디스크 상에 존재하는 이런 파일을 paging file 이라고 함[^paging file]
- 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식. 실제 해당 주소에서 데이터를 읽고/쓸 때만물리 주소로 바꿔준다.
  - virtual address (가상주소) : 프로세스가 참조하는 주소
  - physical address (물리주소) : 실제 메모리 주소
- **MNU (Memory Management Unit)** : cpu에 코드 실행시, 가상 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

![](https://media.vlpt.us/post-images/pa324/96e97500-0221-11ea-85e6-89ef762ea26a/image.png)

### Paging

- 페이징 방식에서는 가상메모리상의 주소공간을 일정한 크기의 페이지로 분할하게 되는데 실제 메모리 또한 가상메모리와 같은 크기로 페이지를 분할
- 페이지의 크기는 대부분 4Kbyte를 사용
- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리



[^paging file]: 윈도우 운영체제에서 일시적으로 메모리의 용량이 부족해지거나 많은 데이터의 입출력이 필요할 순간에 물리적인 하드 디스크의 일정한 빈 공간을 가상 메모리 공간으로 설정하여 메모리 부족으로 인한 병목현상이나 렉이 발생하지 않도록 마련하는 안전장치.

<br><br>



### 가상 메모리 용도

- 여러 프로세스 동시 실행 시스템에서는 가상메모리가 필수적으로 필요 ( = 하나의 프로세스만 실행 가능한 프로그램에선 크게 필요 없음. 배치 처리 시스템)

  - 메모리 용량 부족 이슈

  - 프로세스 메모리 영역간에 침범 이슈

<br><br>



### 메모리 계층 구도 (Memory hierarchy)

CPU가 메모리에 더 빨리 접근하기 위함에 따라 여러가지 종류로 나누어 둠을 의미한다.

- 레지스터와 캐시는 CPU 내부에 존재. 당연히 CPU는 아주 빠르게 접근할 수 있다.
- 메모리는 CPU 외부에 존재한다. 레지스터와 캐시보다 더 느리게 접근 할 수 밖에 없다.
- 하드 디스크는 CPU가 직접 접근할 방법조차 없다. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다. 아주 느린 접근 밖에 불가능하다.
- CPU로부터 가까우면 가격은 비싸지만 성능이 굉장히 빠른 메모리고, 멀어지면 멀어질수록 단가는 싸지만 굉장히 느린 메모리가 됨.





![메모리 계층구조 도식도](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0%EA%B7%B8%EB%A6%BC1.png/440px-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0%EA%B7%B8%EB%A6%BC1.png)



> 위로 갈수록 속도가 빠르고 내려갈수록 용량이 크다는 것을 나타낸다.

출처 [위키백과 - 메모리 계층 구조](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0)

<br><br>

#### 메모리를 계층 구조로 나누는 목적

- **비용적인 측면** : 레지스터, 캐시, 메모리, 하드 디스크는 하드웨어적으로 만들어지는 방법이 다를 때가 많다.  메모리 구조에서 상층에 속할 수록 더 비싸다.
- **자주 쓰이는 데이터는 계속 쓰임(참조의 지역성)** : 자주 쓰이는 데이터는 계속 자주 쓰이고, 자주 쓰이지 않는 데이터는 계속 자주 쓰이지 않는다. 이를 이용해서 운영체제나 CPU는 자동으로 자주 쓰이는 데이터, 또는 자주 쓰일 것 같은 데이터를 메모리에서 캐시로 읽어온다. 자주 쓰이는 데이터는 전체 데이터 양에 비해 작은 양이기때문에, 캐시는 메모리보다 더 작아도 된다. 메모리와 하드 디스크의 관계도 마찬가지이다.
- **속도적인 측면** : CPU와 가까이 있는 레지스터가 가장 빠르게 접근가능하고 밑으로 내려갈수록 접근 속도가 느려짐



<br><br><br>



## 프로세스(Process)

### 프로세스란?

- **실행 중인 프로그램(Program)**. 스케줄링의 대상이 되는 작업(task)과 같은 의미로 사용.
- 프로그램은 보조 기억장치(하드디스크, SSD)에 존재하며 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음인데, 이 프로그램의 명령어와 정적 데이터가 메모리에 `적재`되면  `프로세스`가 된다.
- **프로세스 내부에는 최소 하나의 스레드(thread)**를 가지고있는데, 실제로는 스레드(thread) 단위로 스케줄링을 한다. [^Scheduling]
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 **메모리 할당**이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 **프로세스라** 불린다. 

[^Scheduling]: 프로세스 스케줄링 (Process Scheduling). **CPU 할당 순서 및 방법을 결정**하는 일. ( = 어떤 프로세스를 running 상태로 보낼까)

<br><br>



### 프로세스의 동시 실행

- **하나의 CPU,  즉 프로세서**는 `한 순간`에 `하나`의 프로세스만 실행할 수 있다.
- 프로세스 동시에 여러개 실행될 수 있는 이유는 `운영체제`가 빠르게 CPU가 실행할 프로세스를 교체하고 있기 때문. ( = 속도가 빠르기 때문에 사람은 동시에 여러개의 프로세스가 실행되고 있다고 느끼는 것)



<br><br>

### 프로세스의 관리

- 운영체제는 프로세스들의 실행 사이에 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 관리 필요
- 이를 위해 운영체제는 프로세스의 상태를 `준비`(ready),  `실행`(running), `블록`(block) 상태로 분류
- 프로세스들을 `상태전이`(state transition)를 통해 체계적으로 관리

![프로세스 상태 전이](https://t1.daumcdn.net/cfile/tistory/27733D4856EEACF616)

<center>프로세스 상태 전이</center>



1. **준비(ready)** :  new 상태에서 프로세스가 생성되게 되면 OS 커널[^1]에 존재하는 Ready Queue에 올라간다.
2. **실행(running)** : Ready Queue에 있는 프로세스들을 OS가 위에서 말한 프로세스 스케줄링 알고리즘에 의해서 Running 상태로 가야할 프로세스를 CPU로 할당 -> 프로세스가 Running 상태로 변경
3. **실행 -> 준비** : 현재 running 상태에 있는 프로세스A 보다 Ready Queue에서 대기하고 있는 프로세스 B가 우선순위가 높으면,  preemptive schedule(선점형)인 경우 프로세스A는 Ready 상태로 오게되고 프로세스B가 running 상태로 가서 CPU 할당 받음. **준비**상태에서 **실행**상태로 **상태전이**(state transition) 된다고 하며, 이 과정을 `디스패칭`(dispatching)이라고 하고 **디스패처(dispatcher)가 이 일을 수행**함.
4. **실행 -> 블록(blocked)** : 현재 running 상태에 있는 프로세스A에서 입출력(I/O) 이벤트가 발생했을때 프로세스A가 blocked 상태로 감
5. **블록 -> 준비** : 입출력(I/O) 이벤트가 종료된 프로세스는 다시 준비(Ready) 상태로 오게 됨

> ***\* ready, blocked 상태에는 여러 프로세스가 존재** 할 수 있다
>
> ***\*** 하지만, **싱글코어CPU에서, running 상태의 프로세스는 단 하나**만 존재.



[^1]: 커널(kernel). 컴퓨터 하드웨어와 프로세스를 잇는 핵심 인터페이스. 프로그램의 수행상태인 프로세스 간의 보안 접근을 책임지는 소프트웨어 

<br><br>

### 참고자료

> - [프로세스가 뭐지?](https://bowbowbow.tistory.com/16#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%AD%90%EC%A7%80)



### 프로세스 간 통신 (Inter-Process Communication, IPC)

![img](https://t1.daumcdn.net/cfile/tistory/2641923B5718784D35)

<center>리눅스 커널 구조</center>

- 프로세스는 완전히 독립된 실행 객체이기 때문에 서로 다른 프로세스의 영향을 받지 않지만, 그만큼 서로 통신이 어려움
- 이를 위해 커널 영역에서 IPC 를 제공함 -> 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스 간 통신이 가능
- [위키백과 정의] 내부 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.

<br><br>



### 통신 목적

- 정보 공유 (Information sharing)
  - 여러 사용자가 동일한 정보를 원할 수 있기 때문에 그런 정보를 병행적으로 접근할 수 있는 환경 구성 ( = 공유 파일 등)
- 모듈성 (Modularity)
  - 특정 시스템의 기능을 별도의 프로세스나 스레드로 구분하여 모듈식 형태의 시스템 구성. 각 시스템 모듈이 서로 협력하게 만들기 위함.
- 계산 가속화 (Computation speedup)
  - 특정 작업을 빨리 실행하고자 한다면, 해당 작업을 여러 개의 서브태스크(sub-task)로 나누어서 각각 다른 서브태스크들과 병렬로 실행되게 함.
  - 계산 가속화는 여러 개의 처리요소(processing element - CPU나 입출력 채널 등)들을 가진 경우에만 달성할 수 있음
- 편의성 (Convenience)
  - 개별 사용자들이 동시에 작업할 여러 태스크를 가짐 (= 한 사용자가 편집, 인쇄, 컴파일 등을 병렬로 실행)



<br><br>

### 대표적인 통신 방법

1. **파이프(pipe) - 익명 파이프 (Anonymous Pipe)**

   - 파이프는 통신을 위한 메모리공간(버퍼)을 생성하여 프로세스가 데이터를 주고받게 끔 함.
   - **외부 프로세스와의 통신에도 사용이 가능**하지만 **단방향의 통신**이라는 단점이 존재 ( =. 하나의 파이프를 사용하여 생성하면 데이터의 중복 등의 문제 발생)
   - **외부 프로세스에서는 익명 파이프를 사용할 수 없음.** 부모프로세스가 자식 프로세스를 생성하는 경우에만 가능.
   - 2개의 프로세스가 통신한다고 하면 2개의 파이프를 이용 -> 입출력의 타이밍에 따른 영향을 받지 않아서 문제가 해결된 것 같지만 구현이 복잡하고, 프로세스 수가 늘어날 수록 자원 낭비가 심하다는 단점이 존재.

   ![](https://t1.daumcdn.net/cfile/tistory/9918913359FC74B026)

<center>하나의 파이프</center>



![](https://t1.daumcdn.net/cfile/tistory/99E1BC3359FC780518)

<center>두 개의 파이프 사용</center>



2. **파이프(pipe) - 네임드파이프 (Named Pipe, FIFO)**

   - **외부 프로세스와 통신을 하기 위해서** 파이프에 이름을 붙여주자는 생각으로 네임드 파이프 등장
   - 각 파이프에 이름과 권한을 부여하여 파이프를 생성함으로 부모 프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신 가능.
   - **반이중 통신((Half-Duplex)**이기 때문에 전이중 통신을 원한다면 2개의 파이프 생성 필요 -> 비효율적

   

   ![](https://t1.daumcdn.net/cfile/tistory/99EB1A3359FC7EF536)

   <center>익명파이프와 네임드파이프</center>

   

3. **메시지 큐 (Message Queue)**

   - Queue(큐)는 선입선출의 자료구조를 가지는 통신설비로 커널에서 관리. 

   - 입출력 방식으로 보자면 Named PIPE와 유사한, 프로세스들 간의 데이터 통신(메시지 통신)을 위한 IPC

   - Named PIPE와 다른 점은 Name PIPE가 데이터의 흐름이라면 **메시지 큐는 메모리 공간**이다. 

   - 메시지 큐에 쓸 데이터에 번호를 붙임으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.

     

   ![](http://lh4.ggpht.com/_Os5qf5urx_A/S6uRX3B9hCI/AAAAAAAABQY/6GsGhYufu_Y/s800/s6ki9wihx8SOQltnBlQRyBw.png)

   

   <center>mtype은 메시지 타입. 이것을 이용해 읽고 싶은 메시지만 읽어올 수 있음.</center>

   

4. **공유 메모리 (Shared Memory)**

   - 통신을 이용해 데이터를 주고 받는 것 외에도, **데이터를 아예 공유, 즉 함께 사용하는** 방법이 있다.
   - PIPE, Named PIPE, Message Queue가 통신을 이용한 설비라면, **Shared Memory**는 **공유메모리가 데이터 자체를 공유하도록** **지원**하는 설비.
   - **프로세스간 메모리 영역을 공유해서 사용할 수 있도록** **허용**. 프로세스가 공유 메모리 할당을 커널에 요청 -> 해당 프로세스에 메모리 공간을 할당, 이후 어떤 프로세스건 해당 메모리영역에 접근 가능함.
   - 공유메모리는 중개자가 없이 곧바로 메모리에 접근할 수 있기 때문에 다른 모든 **IPC들 중에서 가장 빠르게** **작동**

   ![img](https://t1.daumcdn.net/cfile/tistory/990CC23359FC85CB07)

   <center>공유 메모리</center><center>프로세스A가 메세지를 공유메모리에 전송하면 프로세스 B가 공유메모리의 메세지를 읽는 방식</center>

   

5. **소켓(Unix Domain Socket)**

   - 물리적으로 멀리 떨어져 있는 컴퓨터끼리의 통신을 도와주기 위한 **통신계층**

   - 컴퓨터와 컴퓨터간의 통신이라고는 하지만 실질적으로는 이쪽 컴퓨터의 **프로세스와 저쪽 컴퓨터의 프로세스가 통신**

     

     ![img](http://lh5.ggpht.com/_Os5qf5urx_A/S6uRbNvlGYI/AAAAAAAABQg/hRN2DM45MZQ/s800/sxVrO5lmNAPD9L_s0mDodMA.png)

     <center>Local 뿐만 아니라, Remote 통신이 가능하다.</center>

   - 가장 큰 장점은 네트워크 통신에 사용하던 기술을 그대로 사용할 수 있다는 점. ( = 코딩의 일관성 유지) 

   - 파이프로도 충분한 간단한 프로그램에 소켓을 사용하는 건 비효율적이긴 하지만 규모가 된다면 소켓 사용이 효율적



### 참고자료

> - [리눅스프로그래밍 소개 - IPC](https://www.joinc.co.kr/w/Site/system_programing/Book_LSP/ch08_IPC)

<br><br>



### 프로세스와 스레드의 차이

#### 프로그램(Program)

- `디스크에 저장된 실행 가능한 명령어(instruction)의 집합`
- 디스크에 저장된 바이너리 형태의 이미지 일 수도 있고, 포토샵 파일도 프로그램이고, 내가 짠 구구단 코드도 프로그램이다.

<br><br>

#### 프로세스(Process)

- `메모리에 적재(load)되어 실행되고 있는 프로그램.`
- 정적인 프로그램과 달리 프로세스는 실제 실행 중인 프로그램을 일컫기 때문에 **동적**이라고 표현하기도 한다.
- **프로세스를 “프로그램의 인스턴스”**라고 표현하기도 한다. ( = 객체지향의 클래스와 인스턴스 격. )
  - 한 클래스가 여러 인스턴스를 생성할 수 있는 것과 같이 **한 프로그램에서 실행되는 여러 프로세스가 동시에 존재할 수 있다.** (ex 윈도우 유저가 메모장 여러개를 실행할 수 있음) 
- 프로세스는 커널에 의해 직접 관리되는데 커널 메모리 안에는 각 프로세스마다 관리하고 있는 프로세스에 대한 데이터들이 있다. 
- Process Control Block(이하 “PCB”)이라고 하는 자료구조 안에 커널 스케쥴러가 프로세스를 제어하는 데 필요한 정보들이 담겨 있다.

<br><br>

#### **스레드(Thread)**

- 프로세스 내에서 실행되는 각각의 일. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 됨
- 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유해서 실제로 **작업을 수행하는 일꾼**

- 기본적으로 하나의 프로세스가 생성되면 하나의 스레드가 같이 생성되며, 이를 **메인 스레드**라고 함 
  - 스레드를 추가로 생성하지 않는 한 모든 프로그램 코드는 메인 스레드에서 실행
- 일반적으로 하나의 프로세스는 하나의 스레드를 갖지만, 여러 개의 스레드를 가질 수 있다 -> 멀티 스레드

![img](https://blog.kakaocdn.net/dn/c03dAx/btqBEz6o9Lb/iCB5si14jlPNFXT5701sx1/img.png)

<center>멀티 스레드의 구조</center>

<br><br>

#### 스레드와 프로세스

|                                           | **Process**                     | **Thread**                                                   |
| ----------------------------------------- | ------------------------------- | ------------------------------------------------------------ |
| 정의                                      | 실행 중인 프로그램              | 경량화된 프로세스 ( = 프로세스의 실행 단위)                  |
| 생성 / 종료 시간                          | 많은 시간 소모                  | 적은 시간 소요                                               |
| **컨텍스트 전환**<br>(context switch)[^2] | 많은 시간 소요                  | 적은 시간 소요                                               |
| 독립성                                    | 각각의 Memory space를 차지한다. | 프로세스 안에서 동작하며 Code, Data, Heap 영역을 공유하고 <br>별도의 Stack만 가지고 있다. |



[^2]: CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정. 구체적으로 다른 프로세스의 수행을 위해 실행되고 있는 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업. 컨텍스트 전환 시간은 하드웨어에 지원에 따라 크게 달라지기 때문에 시스템마다 다르며, 컨텍스트 전환이 일어나는 동안은 아무런 작업이 수행되지 않아 순수한 오버헤드(overhead)[^3]다.

[^3]: 오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다. 예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데, 안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면, 오버헤드는 5초가 된다. 또한 이 처리 B를 개선해 B'라는 처리를 한 결과, 처리시간이 12초가 되었다면, 이 경우 오버헤드가 3초 단축되었다고 말한다

<br><br>

#### 멀티 프로세스와 멀티 스레드

- **멀티프로세스(multi-process), 멀티 프로세싱 이란?**
  - 여러개의 프로세서가 작업을 병렬적으로 처리
  - 프로세스가 하나의 작업(job/task)를 전담하는 것이 아니라 하나의 작업을 처리할 때도 여러개의 프로세스가 협력적으로 작업을 처리
- 멀티 프로세스의 장점
  - 단일 프로세싱을 이용할 때보다 비용 절감
  - 일부 프로세스에 문제가 발생했을 때 프로세스가 작업을 나눠 실행하기 때문에 영향이 확산되지 않음 ( = 신뢰성 증가)
- 멀티 프로세스의 단점
  - Context Switching에서의 오버헤드[^3]. Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생
  - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
  - 프로세스 사이의 어렵고 복잡한 통신 기법(IPC). 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.



![](https://s3.ap-northeast-2.amazonaws.com/static.gracieuxyh.dev/os/multi-processing.png)



<center>멀티 프로세스의 작업 분산</center>

<br><br>



- **멀티 스레드(Multi-threading) 이란?**

  - 하나의 프로세스를 여러 개의 실행 단위이며, 여러 개의 스레드끼리 자원을 공유하는 것. 각 스레드로 하여금 하나의 작업을 처리하도록 함.
  - 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.
  - 웹서버는 대표적인 멀티 스레드 응용 프로그램

- 멀티 스레드의 장점

  - 시스템 자원 소모 감소 ( = 자원의 효율성 증대). 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원 효율적 관리 가능
  - 시스템 처리량 증가 ( = 처리 비용 감소). 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 감소. 스레드 사이의 작업량이 작아 Context Switching이 빠르다.
  - 간단한 통신 방법으로 인한 프로그램 응답 시간 단축. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.

- 멀티 스레드의 단점

  -  단일 프로세스의 경우 효과 기대가 어려움
  - 다른 프로세스의 스레드 제어 불가능 ( = 프로세스 밖에서 스레드 각각 제어 불가능)
  - 자원 공유의 문제가 발생할 수 있다. ( = 동기화 문제)
  - 하나의 스레드에 문제 발생 시, 전체 프로세스가 영향을 받는다.

  

  ![멀티 쓰레딩과 멀티 프로세싱의 차이](https://t1.daumcdn.net/cfile/tistory/995444505AD60F8314)

  <center>싱글 스레드와 멀티 스레드의 차이</center>



<br><br>

##### 멀티 스레드를 사용하는 이유

프로그램을 여러 개 실행하는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것

![](https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png)

<br><br>

#### ❓**멀티 프로세스로 할 수 있는 작업을 멀티 스레드로 하는 이유**

- 자원의 효율성 증대 
  - 프로세스를 생성하여 자원을 할당하는 시스템 호출(System Call)이 줄어들어 자원을 효율적 관리 가능. (프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문)
  - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 감소
- 처리 비용 감소 및 응답 시간 단축
  - 프로세스 간의 통신(IPC) 보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신 부담 감소 ( = 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문)
  - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다 ( = 컨텍스트 전환 시, 스레드는 stack 영역만 처리하기 때문)
- **주의할 점**
  - 안정성 측면에서는 멀티 프로세싱이 안정적
  - 동기화 문제
  - 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.

<br><br>

### 참고 자료

>- [[OS\] 프로세스와 스레드의 차이](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
>
>- [process와 thread에 대한 정리 – 마기의 개발 블로그 – 즐겁게 개발을 하고 싶은 욕심 많은 개발자](https://haedallog.tistory.com/138)
>
>- [프로세스(Process)와 스레드(Thread)](https://velog.io/@naljajm/프로세스Process와-스레드Thread-btk169s36j)
>- [프로세스와 쓰레드의 차이](https://juyoung-1008.tistory.com/47)
>
>- [[IT 기술면접 준비자료] Process와 Thread의 비교]( https://preamtree.tistory.com/10)
>
>- [프로세스와 스레드의 차이](https://brunch.co.kr/@kd4/3)
>- [Difference between Process and Thread](https://www.geeksforgeeks.org/difference-between-process-and-thread/)
>- [[운영체제]프로세스가 뭐지?](https://bowbowbow.tistory.com/16)
>- [OS 바로 알기](https://boanin.tistory.com/84)
>- [[etc]프로세스와 쓰레드의 차이](https://heecheolman.tistory.com/49)
>- [[Programming/Dev Technic]멀티 쓰레딩과 멀티 프로세싱의 차이](https://xeros.dev/63)
>- [[OS] 멀티프로세싱, 멀티프로그래밍, 멀티태스킹, 멀티스레딩](https://velog.io/@chy0428/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1)



<br><br><br>



## 스레드와 동시성(Concurrency)

#### 동시성이란?

- 병행성이라고 한다. ( 병렬성은 여러 Task가 **정확히 동시에 실행** 되는 것)
- 동시성(병행성)은 2개 이상의 Task가 **진행(making process)**되고 있는 것
- 사용자가 보기에는 동시에 진행하고 있는 것 같지만, 내부적으로는 한 번에 하나의 Task만 진행하고 있음 ( ex : Time Slicing 방식)
- 운영체제가 프로세서 시간을 나눠서, 여러 프로세스를 빠르게 전환하여 실행하는 방식
- 다중 프로그래밍 시스템에서 가질 수 있는 성질

<br><br>

#### 동시성 vs 병렬성

| 동시성(Concurrency)                                        | 병렬성(Parallelism)                                       |
| ---------------------------------------------------------- | --------------------------------------------------------- |
| 동시에 실행되는 것 같이 보이는 것                          | 실제로 동시에 여러 작업이 처리되는 것                     |
| 싱글 코어에서 멀티 쓰레드(Multi thread)를 동작 시키는 방식 | 멀티 코어에서 멀티 쓰레드(Multi thread)를 동작시키는 방식 |
| 한번에 많은 것을 처리                                      | 한번에 많은 일을 처리                                     |
| 논리적인 개념                                              | 물리적인 개념                                             |

<br><br>

#### **비동기(Asynchronous) 프로그래밍**

- 프로그램의 주 실행 흐름을 멈추어서 기다리는 부분 없이 바로 다음 작업을 실행할 수 있게 하는 방식
- 코드의 실행 결과 처리를 별도의 공간에 맡겨둔 뒤 결과를 기다리지 않고 바로 다음 코드를 실행하는 병렬처리 방식

<br><br>



### 참고자료

> - [동시성 관련 개념](https://medium.com/@ahaljh/%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B4%80%EB%A0%A8-%EA%B0%9C%EB%85%90-d2f3e6a62b99)
> - [동시성(Concurrency) vs 병렬성(Parallelism)](https://seamless.tistory.com/42)
> - [동시성 프로그래밍/ 비동기 프로그래밍](https://velog.io/@chan33344/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
> - [[부트코스트] ios 프로그래밍](https://www.edwith.org/boostcourse-ios/lecture/16866/)

<br><br>

<br>

## 스케줄링(scheduling)

> **스케줄링**(scheduling)은 다중 프로그래밍을 가능하게 하는 운영 체제의 동작 기법이다. 운영 체제는 프로세스들에게 CPU 등의 자원 배정을 적절히 함으로써 시스템의 성능을 개선할 수 있다.
>
> 출처 [위키백과](https://ko.wikipedia.org/wiki/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%8C%85))

- 여러 프로세스가 있고, 이 프로세스들이 자원(CPU 등)을 동시에 요구하는데 자원은 제한 -> 제한된 자원들을 어떻게(순서를 할당하는 등) 나눠줄 것인지에 대한 정책
- 프로세스가 생성되어 완료될 때 까지 프로세스는 여러종류의 스케쥴링 과정을 거치는데, 이 때의 스케줄링의 종류로는 장기 스케줄링, 중기 스케줄링, 단기 스케줄링이 있다.

<br><br>

### 스케줄링 방식

스케줄링에는 크게 **선점형(Preemptive) 스케줄링**과 **비선점형(Non-Preemptive) 스케줄링** 2가지 방식으로 나뉜다.

- 선점형(Preemptive) 스케줄링
  - 프로세스가 CPU를 할당받아 실행 중이더라도 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 CPU를 강제로 빼앗을 수 있는 방식
  - CPU 처리 시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하지만 잦은 스위칭으로 오버헤드[^3]가 많이 발생한다.
- 비선점형(Non-Preemptive) 스케줄링
  - 선점형과 반대로, 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식
  - 한 프로세스가 CPU를 점유했다면, I/O나 인터럽트가 발생 또는 프로세스가 종료될 때까지 다른 프로세스가 CPU를 점유하지 못함
  - 필요한 스위칭만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스 배치에 따라 효율성 차이가 많이 난다.

<br><br>

### 스케줄링 종류

- **First-Come, First-Served(FCFS)**

  - **FCFS는 비선점형(Non-Preemptive) 스케줄링으로**, 먼저 온 프로세스가 먼저 CPU를 점유하는 방식  

    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZ9jL9%2FbtqFViTF5IZ%2FUs7YfbWFu9yRsqLM28IhXk%2Fimg.png)	

  - 프로세스가 차례대로 **P1, P2, P3** 순서대로 들어온 것을**Convoy Effect**라고 한다

  - CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그만큼 오래 기다리는 것. FCFS의 단점 중 하나.

- **Shortest-Job-First(SJF)**

  -  **SJF**는 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 방식

  - SJF는 선점형(Preemptive)과 비선점형(Non-Preemptive) 방식 모두 가능

    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbmhyjZ%2FbtqFUSgBiun%2F8KU0KSh8kdfdnTK2iaLD7K%2Fimg.png)

  - 수학적으로 어떤 방식보다 평균 대기시간이 짧다고 할 수 있지만 매우 **비현실적**

  - 현실적인 컴퓨터 환경에서는 프로세스의 CPU 점유 시간을 알 수 없을뿐더러 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수밖에 없다. (= 큰 오버헤드를 발생시키므로 잘 사용되지 않음)

- **Priority**

  - **Priority** **스케줄링**은 우선순위가 높은 프로세스 먼저 선택되는 스케줄링 알고리즘

  - **Priority 스케줄링**은 역시, **선점형(Preemptive)과 비선점형(Non-Preemptive) 방식** 모두 가능

    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FyHttx%2FbtqFS1FDRqB%2FV4Z4FZ7gf4CUjvdu9KJ9O1%2Fimg.png)

  - 우선순위를 정하는 방법에는 크게 내부적인 요소와 외부적인 요소로 나뉨

    - **Internal:** Time limit, Memory Requirement, I/O to CPU burst(I/O 작업은 길고, CPU 작업은 짧은 프로세스 순)
    - **External:** Amount of funds being paid, Political Factors 등

  - Priority 스케줄링의 **문제점**은 **Starvation(기아)** 이다. -> 프로세스가 CPU 점유를 오랫동안 하지 못하는 현상

  - 새로운 프로세스가 끊임없이 들어올 때 우선순위가 낮은 프로세스는 계속 대기해야 하는 상태

  - 이를 해결하는 방법으로 **Aging** -> 우선순위가 낮은 프로세스가 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 방식. (우선순위가 낮더라도 시간이 지나면 우선순위가 높아지므로 수행될 가능성이 높아짐)

- **Round-Robin(RR)**

  - 일정 시간(Time Quantum, Time Slice)을 정하여 각각의 프로세스가 이 시간 동안만 수행하고 다시 대기 상태로 돌아가는 방식 

  - 기본적으로 선점형(Preemptive) ( = 일정 시간이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문)

    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5C8rN%2FbtqFUAtLU2L%2FS98y3T4zmReOQA2QjTnsW0%2Fimg.png)

  - **RR**방식은 **Time Quantum**의 크기에 따라 매우 의존적

  - **Time Quantum** 크기를 무한에 가깝게 설정한다면 **FCFS**와 동일하게 동작하고. 반대로, 매우 작게 설정하면 스위칭 오버헤드가 매우 커서 비효율적( =  Time Quantum 값을 적당한 크기로 설정 필요)

<br><br>

### 참고자료

> - [[운영체제(OS)] 6. CPU 스케줄링](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-6.-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
> - [[OS] 프로세스 스케줄링(CPU 스케줄링, 스케줄링 알고리즘)](https://cjwoov.tistory.com/58?category=881451)

<br><br>

<br>

## 기본적인 네트워크 개념 

### 네트워크(network)란?

- Net+Work의 합성어로, 컴퓨터들이 통신 기술을 이용하여 그물망처럼 연결된 **통신 이용 형태**. 주로 `통신망`  이라고 불림. ( = 두 대 이상의 컴퓨터를 연결하여 서로 통신(이야기) 할수 있는 것)
- 전송매체를 링크로 서로 연결된 장치(또는 노드 -node-)의 모임
- 노드(node)는 컴퓨터나 프린터, 스마트폰, 노트북, 데이터 송수신 장치 등등
- 케이블이나 전화선, 무선 링크 등으로 연결되어 동일한 프로토콜을 사용하는 디바이스들의 집합.

<br>

### 프로토콜(protocol)의 의미

- 네트워크의 정보를 공유하기 위해 필요한 약속.
- Ex : 한국인 A와 한국인 B가 서로 대화를 하면 '한국어'라는 언어(프로토콜) 사용 -> 대화(통신) 가능 / 한국인. A와 일본인 C는 사용하는 언어(프로토콜)이 다르기 때문에 대화(통신) 불가능 -> 한국인 A와 일본인 C가 대화(통신)을 하기위해 서로 어떤 언어를 쓰자는 약속 필요 =>  프로토콜

<br>

<br>

 ### 네트워크의 구성요소

- 하드웨어적인 구성요소
  - **Network Interface Card (NIC)** = LAN 카드(컴퓨터 메인보드 랜) 
  - **Network Servers** = File Servers, Mail Servers, Printer Servers, DB Servers 등 
  - **LAN 주변장치** = 프린터, 대용량 저장장치, 모뎀, 팩스 
  - **LAN Workstation** = PC, UNIX 등 - 라우터, 스위치, 허브, 커뮤니케이션 서버, 파이어월
- 소프트웨어적인 구성요소
  - **Network Operating System** = Netware(IntraNetWare), Windows NT Server 등
  - **Communication Software** = TCP/IP Software , VPN 등
  - **LAN Applications**

<br>

<br>

### 네트워크의 분류

네트워크의 분류는 **전송방식, 연결형태, 망의 규모, 통신 방법, 서비스 별**로 분류된다.

<br>

#### **전송 방식**

- 아날로그 통신망 : 음성이나 화상 등의 아날로그 정보를 핀폭, 위상, 주파수 형으로 전송하는 통신망
- 디지털 통신망 : 데이터 통신망과 상호 접속시켜 음성, 데이터 등 다양한 서비스를 제공할 수 있는 통신망      

<br>

#### **연결 형태**

성형, 버스형, 링형, 트리형, 그물형, 혼합형이 존재

- 성(Star) 형

  -  중앙에 위치한 주 노드를 통하여 다른 노드들과 통신할 수 있는 네트워크 구조
  - 장애 발견이 쉽고, 관리가 용이하다는 장점이 있지만 주 노드에 장애가 발생할경우, 전체 네트워크 사용이 불가능

  ![성형](https://camo.githubusercontent.com/76d53e7bac3c4058280516597460adc9fd4f5ab8/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323631343543334335383134423634443138)

- 버스(Bus)형

  -  공유 통신 경로를 통해 연결된 클라이언트의 집합을 가리키는 네트워크 구조
  - 노드의 추가 및 삭제가 용이하며 특정 노드의 장애가 다른 노드에 영향을 주지 않음.
  - 공통 배선의 대역폭을 공유 -> 노드 수가 증가하면 배선의 트래픽이 증가하여 네트워크 성능 저하

  ![](https://camo.githubusercontent.com/52b3776345e97096c86bacdb3a404324dc02e3cf/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134424230333935383134423537393241)

- 망(Mesh)형

  - 모든 노드가 서로 일대일로 연결된 그물망 형태로 다수의 노드 쌍이 동시 통신 가능

  - **완전 연결형**과 **부분 연결형**으로 분류

  - 하나의 노드에 장애가 발생해도 다른 노드에 영향을 주지 않으며 회선 장애에 유연한 대처가 가능

  - 새로운 노드 추가 시 추가적인 비용 부담 필요

    ![](https://camo.githubusercontent.com/57e02807242593237d56d3c5168ecd32e898df64/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134394333333935383134423537423244)

    ![](https://camo.githubusercontent.com/9e2ea20cd7061c8af844cecb3d50b84c4fc6ed3c/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323534423730333935383134423537413241)

<br>

#### 망의 규모

| 거리에 따른 분류             | 설명                                                         | 사용 범위                                                    |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| PAN<br>Personal Area Network | 개인용 정보 단말기들 간에 정보를 주고받을 수 있도록 구성한 개인 영역 소규모 네트워크 | 2Km이내 <br>ex) 기업, 캠퍼스 등                              |
| LAN<br>Local Area Network    | 제한된 지역에서 여러 대의 장치들을 서로 연결하는 독립적인 네트워크 | 10 ~ 50Km<br> ex) 서울시 행정망, 대덕연구단지 망, 지역 케이블 방송망 등 |
| WAN<br>Wide Area Network     | 서로 관련이 있는 LAN들을 상호 연결하는 광역 네트워크         | 1개 국가<br>ex) KT, DACOM 등의 서비스 망                     |

<br> 

#### **통신 방법**

- **회선 교환망 (Circuit Swithcing Network)** 
  - 발신 기긱의 접속 정보(다이얼 숫자 등)로부터 교환기가 착신 기기까지의 회선 설정 후, 통신 정보를 송수신하는 통신 방식을 취하는 교환망
  - ex) 전화
- **패킷 교환망 (Packet Switching Network)** 
  - 정보의 송수신을 패킷 교환 방식으로 실현하는 교환망. (ex : 인터넷)
    - 패킷이란 데이터 전송에서 사용되는 데이터의 묶음
- **메시지 교환망 (Message Switching Nework)**
  - 교환기가 일단 호출자의 전체 메시지를 받았다가 이를 적절한 경로를 통해 수신자에게 전달하는 교환망
  - 메시지 전달이 주목적이며, 빠른 응답을 요구하는 응용에는 부적합

<br>

#### **서비스 별**

- **부가가치 통신망 (VAN, Value Added Network)** 
  - 공중 통신 사업자로부터 회선을 대여받아 고도의 통신 처리 기능으로 부가 가치를 높여 서비스를 제공하는 통신망
- **종합정보통신망( IDSN, Integreated Services Digital Network)** 
  - 성격이 다른 서비스를 종합적으로 취급하는 디지털 통신망
- **공중망 (Public Network)** 
  - 통신 사업자나 통신 주관청이 제공하는 교환 접속형 통신망

<br><br>

### **네트워크의 세분화**(OSI 7 Layer Model)

7가지의 계층을 나눈 이유는 데이터의 흐름을 한눈에 파악하고, 서로 다른 장비들의 네트워크 구성을 위해서 계층별로 장비를 나누어 표현하여 보다 쉽게 다가가고 각 층별로 표준을 만들어 서로 다른 장비끼리로도 상호운용이 가능하게 하기 위함.  ( = 1번 계층의 장비와 2번 계층의 장비는 케이블이 다이렉트케이블을 써야한다던 지 2번 계층의 장비와 똑같은 계층의 장비는 크로스케이블을 사용해야 한다던지 등의 이유)

| 계층      | Layer                   | 기능                                                         |
| --------- | ----------------------- | ------------------------------------------------------------ |
| **7계층** | Application (응용)      | 사용자가 직접 응용프로그램들을 제어하는 것. 메일서버, FTP 서버 등 사용자가 원하는 대로 구성, 사용함 |
| **6계층** | Presentation (표현)     | 여러 가지의 다른 데이터 정보들을 공통된 데이터 표현방식을 통해 통합는 것에 대한 규정 |
| **5계층** | Session (세션)          | 여러 응용프로그램들의 연결을 관리하는 규정<br>여러 응용프로그램들의 동시에 사용하는 경우 연결의 확립, 종료에 대한 내용을 가짐 |
| **4계층** | Transport (전송)        | 데이터 전송에 대한 신뢰성, 비신뢰성을 담는 규정<br>전송계층에는 TCP와 UDP라는 통신수단 존재.<br>- **TCP **: 신뢰성을 바탕으로 통신을 하는 방식. 데이터를 전송하는 과정에서 데이터의 누락이 발생시, 누락된 부분을 확인하여 다시 전달하는 통신 방식이다  (= 안전하고, 정확한 데이터 전달을 위해서는 TCP방식을 사용) <br>- **UDP** :  TCP와 다르게 비신뢰성을 바탕으로 통신. 데이터를 전송하는 과정에서 데이터의 누락 발생시, 누락된 부분을 확인하지않고, 바로 다음 데이터를 전송. |
| **3계층** | Network (네트워크)      | IP주소로 관리하는 계층. <br>IP 주소를 통해 전체 네트워크 장비들끼리의 통신을 관리하고 통신을 끝까지 하는 것에 대한 규정 |
| **2계층** | Data Link (데이터 링크) | 데이터 링크 계층은 Mac주소를 통해 관리하는 계층.<br>링크의 전송을 담당하며 물리적인 매체 비트들의 흐름 제어. ( = 인접된 장비들끼리 연결된 구간을 링크라고 하며, 이 구간의 흐름을 제어하고 물리적인 매체(랜카드)를 Mac 주소[^4]를 통해 관리) |
| **1계층** | Physical (물리)         | 물리계층은 컴퓨터끼리 전기적 신호로 통신을 하는 전송매체에 관한 규정<br>대표적으로 랜선, 허브 등이 물리적 계층에 속함 |

[^4]: 랜카드에는 고유의 Mac 주소를 가지고 있으며, 전 세계에서 하나 뿐인 주소를 가짐.

<br>

![OSI 7 계층에 속하는 장비](https://t1.daumcdn.net/cfile/blog/1729123D50FE472B23)

<center>OSI 7 계층에 속하는 장비</center>

