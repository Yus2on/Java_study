# 인터넷(Internet)

인터네셔널 네트워크(International Network)의 합성어로, 전 세계 컴퓨터가 거미줄처럼 엮어진 대규모 컴퓨터 네트워크 통신망. 컴퓨터로 연결하여 TCP/IP (Transmissing Control Protocl/Internet Protocol) 라는 통신 프로토콜을 이용해 정보를 주고받는 컴퓨터 네트워크



## 인터넷은 어떻게 작동될까요?

![호스팅을 알아보기 전](https://camo.githubusercontent.com/85a861286b4a0aa25fdf59f9a122ebbb68c9af22/687474703a2f2f626c6f672e776973686b65742e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30362f2545442539382542382545432538412541342545442538432538352545432539442538342d2545432539352538432545432539352538342545422542332542342545412542382542302d2545432541302538342e706e67)

1. 클라이언트가 URL(Uniform Resource Locator) 주소를 입력하면, URL 주소 중 **도메인 네임** 부분을 DNS(Domain Name Server) 에서 검색.
2. DNS에서 도메인 주소에 해당하는 IP 주소를 찾게 되면, IP주소와 클라이언트가 입력한 URL 정보를 함께 전달.
3. **HTTP 프로토콜**을 사용하여 **HTTP 요청메세지**를 생성
4. HTTP 요청메세지는 **TCP 프로토콜**을 사용해 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송 -> 도착한 HTTP 요청메세지는 HTTP 프로토콜을 사용하여 웹페이지 URL 정보로 변환
5. **웹서버**는 도착한 웹페이지 URL 정보에 해당하는 데이터를 검색 -> 검색된 웹 페이지 데이터는 또다시 HTTP 프로토콜을 사용해 **HTTP 응답메세지**를 생성
6. 이렇게 생성된 응답 메세지는 TCP 프로토콜을 사용해 인터넷을 거쳐 원래의 컴퓨터로 다시 전송된다. 도착한 HTTP 응답메세지는 HTTP 프로토콜을 사용해 웹페이지 데이터로 변환되고, 변환된 웹페이지 데이터는 웹 브라우저에 의해 출력되어 클라이언트가 볼 수 있게 된다.



## HTTP는 무엇일까요?

#### HTTP란?

- Hyper-Text Transfer Protocol
- 텍스트 기반의 통신 규약으로, 인터넷에서 데이터를 주고받을 수 있는 프로토콜. 하이퍼텍스트 문서를 교환하기 위하여 사용된 통신 규약이다.
- 웹에서만 사용하는 프로토콜로, TCP/IP기반으로 클라이언트의 요청과 서버의 응답을 전송한다.
- **무상태(stateless) 프로토콜**. 클라이언트가 요청한 것에 대한 응답을 하기 전, 서버에 연결을 하는데, 이 연결을 응답 후 바로 끊는다. 클라이언트가 바로 다음 것을 요청한다고 하더라도, 서버는 이 클라이언트가 아까 요청했던 클라이언트인지 전혀 알수가 없다.
  - 클라이언트의 이전 상태를 전혀 알 수가 없다는 단점이 있으며, HTTP **쿠키**로 이 문제를 해결하고 있다
  - 쿠키(cookie) : 사용자가 같은 웹사이트를 방문할 때마다 읽힌 정보를 해당 웹사이트의 서버에 저장해 놓는 정보조각. 하드 디스크에 저장함
  - 세션(Session) : Server 하드디스크에 저장하는 객체 데이터. 브라우저와 연결 시 Session ID 생성.
  - 캐쉬(Cache) : Server 나 Client의 RAM(메모리)에 저장. 가장 빠르게 데이터를 가져올 수 있음.





#### HTTP / HTTPS

- HTTP는 암호화 X, HTTPS는 암호화 함.
- 현재는 https를 사용. https는 암호화해서 보내고 서버에서 복호화하기 때문에 안전





#### HTTP Request

- URI 를 통해 IP 주소를 찾으면, 포트번호와 함께 HTTP 프로토콜을 통해 **요청메세지**를 보낸다.
- 요청 메시지는 정해진 규칙에 의하며, 이것을 **요청 데이터 포맷** 이라고 한다.
  - **헤더 , 빈 줄, 요청 바디** 세 부분으로 나뉜다.
- Request Method
  - GET: 클라이언트의 데이터 요청
  - POST: 데이터 전송 기반 메서드. 서버에 데이터 전송
  - PUT: 요청 페이로드를 사용해 새로운 리소스 생성, 대상 리소스를 나타내는 데이터를 대체
  - DELETE:  지정한 리소스 삭제



#### HTTP Response

- 응답 데이터 포맷도 요청 데이터 포맷과 마찬가지로, **1. 헤더부분, 2. 빈줄부분, 3. 응답 바디** 로 구성
- 첫 줄에는 반드시 HTTP 프로토콜 버전, 응답 상태 등을 출력
  - HTTP 응답 코드는 지정한 HTTP 요청이 성공적으로 완료되었는지 출력.
  - 응답은 다섯 가지 클래스로 그룹핑.(HTTP Status Code) **정보성 응답, 성공 응답, 리다이렉트, 클라이언트 에러, 서버 에러.**
    - 정보 응답 ( `100`– `199`),
    - 성공적인 응답, success ( `200`– `299`),
    - 리디렉션, redirection ( `300`– `399`),
    - 클라이언트 오류, request error ( `400`– `499`),
    - 서버 오류, server error ( `500`– `599`).
- 나머지 헤더부분에는 날짜, 웹 서버 이름과 버전, 콘텐츠 타입, 캐시 제어 방식 등의 부가적인 정보 출력
- 빈 줄 다음에는 실제 응답 리소스 데이터 출력



[참조]

[MDN-HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)



## 브라우저와 동작 원리

### 렌더링(Rendering)이란?

- Renderer engine(skia)
- Render는 html로 입력받아 해석해서 표준 출력 장치(모니터)로 출력. 이러한 작업을 Rendering이라고 함.



### 브라우저의 렌더링 과정

렌더링은 화면에 컨텐츠를 그리는 과정으로, 브라우저들은 각자의 렌더링 엔진으로 이를 구현했다. 크롬과 사파리는 “Webkit 엔진”을 사용하고, 파이어폭스는 “Gecko 엔진”을 사용한다.

- HTML을 파싱하여 DOM 트리를 만든다.

- CSS를 파싱하여 CSSOM 트리를 만든다.

- DOM 과 CSSOM 을 결합하여 렌더링 트리를 만든다.

- 렌더링 트리에서 각 노드의 크기와 위치를 계산한다.

- 개별 노드를 화면에 그린다.

  

![브라우저렌더링](https://user-images.githubusercontent.com/35126809/90095425-90df1680-dd6b-11ea-9c27-5f9a23359c65.png)

출처 : http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/



**[Webkit 엔진 동작과정]**

![webkit](https://user-images.githubusercontent.com/35126809/90095491-c421a580-dd6b-11ea-9fd7-3c83e36e3913.png)



**[Gecko 엔진 동작과정]**

![gecko](https://user-images.githubusercontent.com/35126809/90095497-cc79e080-dd6b-11ea-971c-a891d0c9e55b.png)



출처 : https://d2.naver.com/helloworld/59361







## DNS와 작동 원리

### DNS(Domain Name System)란?

- **각 IP주소에 이름을 부여**할 수 있게 했는데, 이것을 **도메인(Domain)**이라고 한다.
- DNS는 도메인 네임 서버로, 도메인 이름과 IP 상호 변환을 가능하게 해주는 서버.
- 도메인과 IP를 연결해주는 역할을 하며, 도메인 등록을 했다 해도 네임 서버에 해당 도메인이 어떤 IP로 연결되었는지 정보가 없다면 접속 불가. (페이지를 표시할 수 없습니다 메시지 출력)   



![도메인 구조](https://camo.githubusercontent.com/7d4d64aef8cee4cd73353c0fca2a9b6536ce43d0/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323331364139334635314334363239343043)

> 인터넷 도메인의 체계에서 최상위는 `루트(root)`로, 인터넷도메인의 시작점이다. 이 루트 도메인 바로 아래 단계에 있는 것을 1단계 도메인이라고 하며 이를 `최상위도메인`이라고 한다. 이를 약어로 **TLD(Top Level Domain)**이라고 한다. 최상위 도메인은 국가명을 나타내는 **국가 최상위 도메인**과 일반적으로 사용되는 **일반 최상위 도메인**으로 구분된다.



### DNS 작동 원리(도메인 질의 과정)

![img](https://camo.githubusercontent.com/1170dbf854c3b241cb3a37e59034f1a032d85eb0/68747470733a2f2f6d626c6f677468756d622d7068696e662e707374617469632e6e65742f4d6a41784e6a45794d4468664e444d672f4d4441784e4467784d5455324e4449784e4467342e736b78794c534d6a6336787345354b547a5f5f6b67564a4355796245624466334c4f47776264664f303773672e615634515461646f6e6e465a724d71554c50454b4e5343446773514b624649456b49726146347334467634672e504e472e64616f756964632f444e532e504e473f747970653d7732)

Local DNS 서버가 여러 DNS 서버를 차례대로 (Root DNS 서버 -> com DNS 서버 -> naver.com DNS 서버) 물어봐서 답을 찾는 과정을 **Recursive Query** 라고 한다.

1. PC 브라우저에서 '[www.naver.com](http://www.naver.com/)' 를 입력했을 때, PC는 미리 설정되어 있는 Local DNS(사용자 단말에 설정되어 있는 DNS를 Local DNS라고 함) 에게 '[www.naver.com](http://www.naver.com/)' 이라는 hostname에 대한 IP 주소를 물어본다.
2. 만약 Local DNS에 호스트네임(host name)에 대한 정보가 있다면 해당하는 IP주소를 PC에 전달하고 PC는 해당 주소에 접속 가능하게 된다. Local DNS에 없다면, 각 Local DNS에 설정된 Root DNS와 통신 (DNS 메시지, 질의)를 시작한다.
   - Root DNS는 전 세계에 13대가 구축되어 있으며, 한국에는 Root DNS 서버에 대한 미러 서버를 3대 운용 중
3. Root DNS 서버가 알고 있다며, Local DNS에게 IP 정보를 전달하고 Local DNS는 IP주소를 캐싱하여 PC에게 전달하면 된다. 캐싱을 하는 이유는 **이후에 다시 같은 주소를 요청받았을 때 바로 답해주기 위함**
4. Root DNS에도 호스트 정보가 없으면 다른 DNS 서버에 질의할 수 있도록 요청한다.
5. 이 다른 DNS는 '.com DNS'로, .com 도메인을 관리하는 DNS 서버(TLD)이다. Local DNS는 다시 .com DNS에게 질의를 요청하고, 요청 결과가 다시 질의할 다른 DNS의 주소를 알려준다.
6. naver.com DNS는 naver.com 도메인을 관리하는 DNS로, 호스트 네임에 대한 질의 요청 결과가 있을 경우 IP 주소(222.122.195.6)를 반환한다.
7. 이를 수신한 Local DNS는 '[www.naver.com](http://www.naver.com/)' 에 대한 IP 주소를 캐싱하고 IP주소 정보를 단말(PC, 클라이언트) 에 전달한다.



[참조]

[netmanias](https://www.netmanias.com/ko/post/blog/5353/dns/dns-basic-operation)

[aws](https://aws.amazon.com/ko/route53/what-is-dns/)







## 호스팅은 무엇일까요?

### 호스팅(Hosting)이란?

- 서버의 전체 혹은 일부를 사용할 수 있도록 임대해주는 서비스 (홈페이지 운영 공간 할당)
- 크게 웹호스팅, 서버호스팅, 클라우드호스팅으로 구분



![호스팅의 종류](https://camo.githubusercontent.com/83dd88a4fa77d58f5f83e00cab0c7a8dc71a6013/687474703a2f2f6c6962726172792e67616269612e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f2545432541302539352545422542332542342545432538322541432545432539442542342545442538412542382d2545442539382542382545432538412541342545442538432538353030332e6a7067)

#### 웹 호스팅

- 하나의 서버 장비를 여러 명이 공유하여 사용하는 것.
- 가장 대중적이며, 호스팅 업체의 통합 관리를 받는다는 장점이 있다.
- 사용할 수 있는 하드웨어가 제한적이고 트래픽 양이 증가하면 서버가 다운되는 등의 제약이 있다.



#### 서버 호스팅

- 한 명의 클라이언트가 하나의 서버를 임대하는 호스팅. 
- 스케일과 트래픽 양이 많은 대형 홈페이지를 구축할 때 사용하며, 고정적으로 트래픽양이 많은 사이트에 적합.
- 서버 운영/관리에 대한 직접적인 권한을 가진다.



#### 클라우드 호스팅

- 물리 서버가 아닌 가상 서버를 임대.
- 자유롭게 서버 스펙 조절이 가능하며, 이용한 만큼만 금액을 지불한다는 장점이 있다.
- 일시적인 트래픽 변동량이 많은 사이트에 적합.



[참조]

[위키백과 - 인터넷 호스팅 서비스](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%98%B8%EC%8A%A4%ED%8C%85_%EC%84%9C%EB%B9%84%EC%8A%A4)

[웹호스팅 / 서버호스팅 / 클라우드 차이점은?](http://library.gabia.com/contents/infrahosting/1311)