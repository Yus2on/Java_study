# OS 및 일반적인 지식

## OS(Operating System; 운영체제)

자원 관리자(Resource Manager) 라고 할 수 있다. 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 물리적 자원(CPU, RAM, Hard Disk) 를 컨트롤 하는 시스템 소프트웨어의 일종으로 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다 ( = 사용자의 편리성 도모)

- 하드웨어를 관리하고, 효율적으로 사용할 수 있는 **Abstraction** 을 제공 

  ![](https://camo.githubusercontent.com/b434b034a49d75bbeb96f629a356bd7e98fc885b/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d687474702533412532462532466366696c6532372e75662e746973746f72792e636f6d253246696d61676525324639393944333233333543344434314542324443354545)

<center>운영체제</center>



<br>

<br>

### 운영체제의 추상화 (OS Abstraction)

- 가상 메모리(Virtualizing Memory), 멀티 태스킹(Multi-Tasking), 동시성(concurrency) 기법 등을 사용
  - 프로세스(process), 스레드(thread), 파일(file), 소켓(socket), 메모리 페이지(memory page), etc
- 이런 추상화 된 기능들을 쉽게 사용할 수 있도록 운영체제에서는 시스템 호출(System Call) 를 제공

<br><br>

### 시스템 호출 (System Call)

> 시스템 호출(system call)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 [커널 (Kernel)](#커널 (Kernel)) 에 접근하기 위한 인터페이스이다. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.
>
> 출처: [시스템 호출](https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C)

**시스템 콜** 또는 **시스템 호출 인터페이스**. 시스템 콜이라고 자주 쓰인다. 운영체제에는 유저 모드, 커널 모드 두 가지 모드가 존재하는데, 유저 모드에서 시스템 콜이 호출 되면 시스템 콜 인터페이스를 통해 커널 모드로 전환 된다. ( = Mode Switch). 이후 운영체제는 커널모드에서 시스템 콜 실행 후 다시 유저모드로 돌아간다.

- 운영체제의 기능을 호출(요청)하는 함수. 유저 모드와 커널 모드 사이의 가상 계층.
- 보통 시스템 콜을 직접 사용하는 대신 해당 시스템 콜을 이용해서 만든 API를 사용한다.

<br><Br>

#### 시스템 호출의 유형 / 예시

- 프로세서 제어(process Control) : fork(), exit(), wait()

- 파일 조작/관리(file manipulation) : open(). read(), write(), close()

- 장치 관리(Device Management) : ioctl(), read(), write()

- 정보 유지(Information maintenance) : getpid(), alarm(), sleep()

- 통신(Communication) : pipe(), shm_open(), mmap()
- 보호(Protection) : chmod(), umask(), chown()

<br><br>

#### 유저모드(User mode)와 커널모드(Kernel mode)

I/O 장치를 보호하기 위해 운영체제는 기본적으로 두 가지 모드를 제공한다. 유저 모드는 어플리케이션이 실행되는 모드이고, 커널 모드는 프로그램이 수행되다가 인터럽트에 걸려 운영체제가 호출되어 수행되는 모드이다. 

유저모드는 시스템 데이터 접근만 허용되며, 하드웨어에 직접 접근이 불가능하다. 

커널모드는 CPU 명령어이고, 특정 권한이 있어야만 수행되는 명령어 이기 때문에 **privileged mode** 라고 불린다. ( = supervisor mode, system mode, monitor mode)

유저모드와 커널모드는  `모드비트 (mode bit)` 로 구분한다. 

- 비트 1 : 유저모드
- 비트 0 : 커널모드 



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJXwNG%2Fbtqw787Kgfe%2FvmrkitiEEjDI8G9w2mFzUk%2Fimg.png)

<br>

<br>

### 커널 (Kernel)

-  사용자가 이용하는 프로그램이 안전하고 효율적으로 작동할 수 있도록 도와주는 컴퓨터 자원 관리 소프트웨어. 운영체제의 핵심 부분을 담당한다.
- 항상 메모리에 상주하기 때문에 **Memory Resident**  라고 함. (커널 외의 프로그램은 Disk Resident -> 항상 현 주소가 disk라는 의미. 필요할 때 메모리에서 로딩해서 사용)

<br><br>

### 메모리 가상화 (Virtualizing Memory)

- CPU 가 생성하는 가상 기억 장치 (virtual storage). 
-  RAM 부족 문제를 해결하기 위한 메모리 관리 기법 중 하나. RAM과 보다 느린 스토리지를 병합하여 시스템에 한 개 이상의 RAM이 설치된 것처럼 보이게 하는 방법.
- 커널이 하는 주요 역할 중 하나.

> TLB (Tranlation Lookaside Buffer) : 가상 메모리 주소를 물리 주소(Physical address)로 변환할 때 사용하는 캐시
>
> page, segmentation : 메모리 가상화를 구현하는 방법
>
> NUMA(Non - Uniform Memory Access) : 멀티 프로세서 시스템에서 사용되는 메모리 설계 방법 중 하나

<br>

<br>

### 멀티 태스킹 (Multi-Tasking)

`Task`란 운영체제에서 처리하던 작업의 단위, 정해진 작업을 수행하기 위한 명령어 집합체이다. ( = Process 보다 확장된 개념) `멀티 태스킹` 은  이러한 다수의 Task를 운영체제의 스케줄링에 의해 **Task 번갈아가며 수행하는 것** 을 의미한다.

- 여러개의 task가 번갈아가며 수행되다 보니 사용자는 동시에 여러 task가 수행되고 있다고 느낌

  ![](https://media.vlpt.us/images/chy0428/post/a64f2dfe-19be-4ee8-8e96-15001957bc15/image.png)

<br>

<Br>

#### 멀티 태스킹과 멀티 프로래밍(Multi-Programming) 

- 멀티 프로그래밍은 **프로세서의 자원낭비를 최소화**시키기 위한 것
- 멀티 태스킹은 **정해진 시간동안 교대로 Task 를 수행**하는 것 ( = 인터넷을 하면서 음악을 듣는 것 등)
- 여러 일을 동시에 교대로 처리한다는 점에선 공통점을 가짐

<br>

#### 멀티 태스킹과 멀티 스레딩(Multi-threading)

- 멀티 스레딩은 서로 간의 자원공유가 가능하며 프로그래밍을 통한 구현이 가능하다.
- 멀티 태스킹은 운영체제(OS)에서 지원하는 것으로, 서로 자원 공유가 불가하다. 자원 공유를 위해선 별도의 IPC 를 구현해야 한다. ( = 멀티 스레딩에 비해 운영체제에 부담을 줄 수 있음)

<br><br>

### 동시성(concurrency)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcSRaKk%2FbtqwVhqNdv4%2FN2JTBYr4DGN1Q2EcrvLeFK%2Fimg.jpg)



<center>
  동시성(concurrency) : 하나의 커피머신에서 커피를 받기 위해 두 줄로 서서 번갈아 가며 사용<br>
  병렬처(parallelism) : 두 개의 커피머신이 존재하며 각 머신마다 하나의 줄을 갖고 있어서 줄마다 사용 가능
</center>

<br><br>

#### 레이스 컨디션 (Race Condition)

- 프로세스들이 동시에 자원을 사용하기 위해 경쟁하는 것.
- 같은 시스템이나 프로그램에서 동시에 실행하려 할 때 생기는 문제를 말한다. ( = CPU 우선권을 차지 하기 위한 경쟁)
  - 트랜잭션(Transaction)은 더 이상 나눌 수 없는 업무 처리의 단위. (더 이상 나눌 수 없다 = 원자성을 보장해야 한다)
  - **원자성(Atomicity)**은 특정 **실행 컨텍스트(Context)**에서 더 이상 나눌 수 없는 연산을 의미. 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. (Ex: 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것)
- Race Condition Attack : 경쟁하는 프로세스들을 이용해서 관리자 권한을 얻는 공격 방법

<br><Br>

### 참조자료

> - [Operating System: Introduction](https://medium.com/@akhandmishra/operating-system-introduction-ba5bb9c438bc)
> - [운영체제(Operating System) 핵심 개념 정리 (2)](https://wkdtjsgur100.github.io/os-summary-2/)
> - [[운영체제] 커널 모드, 사용자 모드](https://kosaf04pyh.tistory.com/196)
> - [위키피디아 - 시스템 호출](https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C)
> - [운영체제 #1_ 스레드와 프로세스, 멀티프로그래밍,멀티태스킹,멀티스레딩,멀티프로세싱](https://doorbw.tistory.com/26)
> - [트랜잭션이란](https://sjh836.tistory.com/11)
> - [동시성 소개](https://velog.io/@kineo2k/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%86%8C%EA%B0%9C)

<br><br><br>

## 터미널 (Terminal)

#### 터미널이란?

- 키보드와 모니터 등으로 이루어진 단말기
- 주로 명령줄 모드 (CLI; Command Line Interface)를 나태낸다. ( = 텍스트 기반 명령을 입력/실행하는 인터페이스)
- 기술적으론 다른 의미지만 **Terminal, Console, Shell, Command Line** 으로 불리기도 한다.
- Linux OS 에서는 bash, tcsh 등. Window 에서는 cmd 기반으로 사용되고 있다.

<br>

#### CLI 와 GUI

- CLI (Command Line Interface) 
  - 가상 터미널을 통해 사용자와 커퓨터가 문자열의 형태로 입/출력을 주고 받는 명령줄 인터페이스
  - GUI 보다 안정적이며 자원을 적게 소모
- GUI (Graphic User Interface)
  - 그래픽 유저 인터페이스. 
  - 문자 그대로 사용자의 편의를 위해 입/출력 등의 기능을 직관적인 아이콘이나 그래픽으로 표시. (Ex: 윈도우의 아이콘 등)

<br>

#### 터미널 환경

- 대부분 백엔드 시스템은 리눅스 기반 서버에서 운영 -> 리눅스 서버에 접속하여 터미널을 통한 작업이 많음
- Windows -> CMD 창 / Mac OS -> Terminal 이 CLI 제공 응용 프로그램. 크게 입 / 출력 단위로 구성.
  - Windows '>' 형태 / Mac Os, Linux '$' 형태의 명령 프롬프트(Command Prompt) 가 존재
  - 사용자가 특정 명령어를 통해 입력 -> 셸 프로그램이 입력 받는 명령어를 해석 -> 명령에 해당하는 내용을 출력

<br><br>

#### 자주 사용되는 명령어

1. `ls`：지정한 파일 또는 디렉토리를 표시한다

   - Mac OS, Linux 등 bash(Bourne-Again Shell) 프로그램을 사용하는 터미널은 `ls` 명령어 사용

     ```
     # Mac OS, Linux, ...
     
     $ ls
     $ ls -a # 숨김파일까지 확인 가능
     $ ls -la # 상세보기 la 만 사용 가능
     ```

   - Windows 등 DOS(Disk Operating System) 기반 명령 프롬프트를 사용하는 커맨드는 `dir` 명령어 사용

     ```
     # Windosws ...
     
     > dir
     ```

- `cd`：Change Directory 의 약자. 다른 디렉토리로 이동.

  ```
  # 공통 명령어
  
  $ cd <현재 디렉토리의 폴더 이름>  # 그 폴더로 이동
  $ cd <디렉토리>               # 특정 디렉토리로 이동
  $ cd ../                    # 상위 디렉토리로 이동
  $ cd ~                      # 루트 디렉토리로 이동
  ```

- `sudo`： superuser do. 현재 계정(일반 사용자)에서 **root 권한을 이용하여 명령어를 실행**할 때 사용.

  ```
  # 공통 명령어
  # sudo 다음에 실행할 명령을 입렵하면 root 권한으로 명령어를 실행
  
  $ sudo apt-get update
  ```

- `pwd`：print working directory 의 약자. 공통 명령어. 현재 작업 중인 디렉토리의 절대 경로를 출력, 내 위치가 궁금할때 사용함.

  [![pwd 명령어](https://camo.githubusercontent.com/312b75cca6bbee76535fc75434a736228d53ce86/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d687474702533412532462532466366696c6532332e75662e746973746f72792e636f6d253246696d61676525324632343430393734393536453346413236323038313330)](https://camo.githubusercontent.com/312b75cca6bbee76535fc75434a736228d53ce86/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d687474702533412532462532466366696c6532332e75662e746973746f72792e636f6d253246696d61676525324632343430393734393536453346413236323038313330)

- `mkdir`：make directory의 약어로서 새로운 디렉토리를 만들때 사용

  ```
  # 공통 명령어
  
  $ mkdir [옵션] 생성할 디렉토리 이름
  
  $ mkdir linux # 현재 경로에 linux 라는 디렉토리 생성
  $ mkdir -p girls/tiffiny # 상위 디렉토리 경로를 포함하는 디렉토리 생성
  ```

- `rm`： Remove의 약자. 일반적으로 하나 이상의 파일을 삭제할 때 사용하며 옵션 값을 입력하면 디렉토리도 삭제가 가능.

  ```
  # 공통 명령어
  
  $ rm [옵션] 파일명/디렉토리명
  
  $ rm -f test.txt # test.txt 라는 파일을 삭제 여부 묻지 않고 강제 삭제
  ```

<br><br><br>

## 메모리(Memory)

#### 메모리란?

- 데이터를 기록하거나 읽기 위한 저장공간
- 크게 램(RAM; Random Access Memory) / 롬(ROM; Read Only Memory) 로 분류

<br><br>

#### 메모리 계층 구도 (Memory hierarchy)

![](https://camo.githubusercontent.com/3de775df0dd7528e09f841aa8bae454824f2708e/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f632f63362f254542254139253934254542254141254138254542254136254143254541254233253834254543254238254235254541254235254143254543254131254230254541254237254238254542254136254243312e706e672f34343070782d254542254139253934254542254141254138254542254136254143254541254233253834254543254238254235254541254235254143254543254131254230254541254237254238254542254136254243312e706e67)

<center>메모리 계층 구도. <br>위로 갈 수록 속도가 빠르고, 아래로 갈 수록 용량이 크다</center>



- CPU가 메모리에 더 빨리 접근하기 위함에 따라 여러가지 종류로 나누어 둔 것을 의미
- 레지스터와 캐시는 CPU 내부에 존재 -> CPU는 아주 빠르게 접근 가능
- 메모리는 CPU 외부에 존재 ->  레지스터와 캐시보다 더 느리게 접근 할 수 밖에 없음
- 하드 디스크는 CPU가 직접 접근할 방법조차 없다. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다 -> 아주 느린 접근만 가능
- CPU로부터 가까우면 가격은 비싸지만 성능이 굉장히 빠른 메모리고, 멀어지면 멀어질수록 단가는 싸지만 굉장히 느린 메모리

<br><br>

#### 메모리를 계층 구조로 나누는 목적

- **비용적인 측면** : 레지스터, 캐시, 메모리, 하드 디스크는 하드웨어적으로 만들어지는 방법이 다를 때가 많다. 메모리 구조에서 상층에 속할 수록 더 비싸다.
- **자주 쓰이는 데이터는 계속 쓰임(참조의 지역성)** : 자주 쓰이는 데이터는 계속 자주 쓰이고, 자주 쓰이지 않는 데이터는 계속 자주 쓰이지 않는다. 이를 이용해서 운영체제나 CPU는 자동으로 자주 쓰이는 데이터, 또는 자주 쓰일 것 같은 데이터를 메모리에서 캐시로 읽어온다. 자주 쓰이는 데이터는 전체 데이터 양에 비해 작은 양이기때문에, 캐시는 메모리보다 더 작아도 된다. 메모리와 하드 디스크의 관계도 마찬가지이다.
- **속도적인 측면** : CPU와 가까이 있는 레지스터가 가장 빠르게 접근가능하고 밑으로 내려갈수록 접근 속도가 느려짐

<br><br>

#### 메모리의 종류

![메모리의 종류](https://camo.githubusercontent.com/46c4a4cf75080c5fdc9e6682ba922fcaecc8a10f/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323334433139343235324445303138323133)

<center>메모리의 종류</center>

<br>

| 휘발성 메모리            | 비 휘발성 메모리      |
| ------------------------ | --------------------- |
| RAM (랜덤 액세스 메모리) | ROM (고정 기억 장치)  |
| DRAM (동적 램)           | NVRAM (플래시 메모리) |
| SRAM                     | MRAM                  |
| 내용 주소화 기억 장치    |                       |

<br>

#### **RAM (Random Access Memory)**

- 데이터를 저장하거나 저장된 데이터를 읽어내는 기억장치로, 전원 공급을 끊으면 기록한 데이터가 소실되는 휘발성 메모리이다.
- 컴퓨터가 인터넷, 스프레드 시트 편집 등 일상적인 여러 작업을 수행할 때 사용되거나 다른 작업으로 전환 시 이전 작업의 마지막 위치를 기억해 빠르게 작업을 전환하는데 필요.
- 크게 SRAM(Static RAM) 과 DRAM(Dynamic RAM)으로 분류
  - SRAM : 전원을 공급하면 데이터를 유지할 수 있는 플립플롭 회로(filp - flop circuit) 를 사용. 제어가 쉽고 동작이 빠르지만 대용량화에 적합하지 않다는 단점이 존재
  - DRAM : 커패시터(Capacitor) 에 전하를 축적해 데이터 유지. 정기적으로 리프레시(Refresh) 신호를 주지 않으면 데이터가 소실되며 제어가 복잡하다. 대용량화에 적합. 

<br>

#### ROM (Read Only Memory)

- 읽기 전용 메모리로, 전원 공급이 끊어져도 데이터가 소실되지 않는 비 휘발성 메모리. 다시 작성할 필요가 없는 프로그램이나 데이터 저장에 사용
- 크게 데이터를 기록하는 `mask ROM` 과 유저가 데이터를 기록할 수 있는 `PROM(Programmable ROM)` 으로 나눔
  - Mask ROM : 가장 기본적으로 일반적인 ROM. 제조사에서 ROM 제작 시 데이터를 저장해두는데 후에 지우거나 덮어씌우는 것이 불가능
  - PROM : 사용자가 바로 데이터를 기록할 수 있는 ROM. PROM 은 다시  OTP, EPROM, EEPROM 등으로 나뉨.
  - OTP(One Time PROM) : 1회만 쓰기(수정)가 가능한 ROM. 한 번 수정하게 될 경우, 데이터 수정이 불가능.
  - EPROM(Erasable PROM) : 저장되어 있는 데이터를 쓰고 지울 수 있는 ROM. 데이터를 지우는 방법에 따라 EEPROM, UVEPROM 으로 분류
    - EEPROM(Electrically Erasable PROM) : 고전압(high voltage)으로 저장된 데이터를 지우고, 삭제된 공간에 데이터를 다시 기록할 수 있는 메모리. 1byte 씩 삭제하기 때문에 속도가 느림.
    - UVEPROM(Ultra-Violet EPROM) : 자외선 사용하여 저장된 데이터를 지울 수 있는 ROM

<br>

#### 플래시 메모리 (Flash Memory)

- EEPROM의 한 종류. 기존 PROM 종류보다 빠르게 기록과 삭제가 가능.
- RAM 처럼 읽고 쓰기가 쉬우면서 ROM처럼 비휘발성 메모리라는 장점이 있음
- 구조에 따라 NOR / NAND형 메모리로 분류
  - NOR : 데이터 유지에 있어 오류가 적지만 지우기 속도가 느려 고속화 적용 X. 대용량화가 어렵다는 단점.
  - NAND : 소형 -> 대용량화 가능 -> 휴대기기에 주 사용

<br><br>

#### 가상 메모리(virtual memory)

- 가상 기억 장치 (virtual storage). 메모리 관리 기법 중 하나. 

- 실제 프로세스마다 메모리를 각각 할당하기에는 메모리의 한계가 있기 때문에 OS(운영체제)에서 디스크 공간을 메모리처럼 활용할 수 있도록 기능을 제공한다. 

- 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 방식을 주며, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 변경

  - virtual address (가상주소) : 프로세스가 참조하는 주소
  - physical address (물리주소) : 실제 메모리 주소

- 멀티태스킹에 흔히 사용되고, 실제 주기억장치(RAM) 보다 큰 메모리 영역을 제공

  - MMU(Memory Management Unit): CPU에서 코드 실행 시, 가상 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치. 매핑(mapping)을 지원한다.

    ![](https://camo.githubusercontent.com/4c99c82a10b39b4caae3ca65b07149d8f09e71b1/68747470733a2f2f6d656469612e766c70742e75732f706f73742d696d616765732f70613332342f39366539373530302d303232312d313165612d383565362d3839656637363265613236612f696d6167652e706e67) 



<br><br>

#### 매핑(Mapping)

- MMU하드웨어에 의해 지원되는 기능으로 가상 메모리와 실제 메모리 사이의 중계 역할
- Paging과 Segmentation 방식을 혼합한 방법.

<br><br>

#### 페이징과 세그멘테이션

##### 페이징(Paging) 기법

- 프로세스의 주소 공간을 동일한 크기의 페이지(page) 단위로 나누어 불연속적인 메모리 공간에 저장하는 방식
- 페이징 기법으로 물리 메모리는 연속적으로 할당되어 존재할 필요가 없으며, 연속적으로 존재하지 않더라고 페이징 기법을 통해 연속적으로 존재하는 것처럼 이용 가능
- 가상 메모리 상의 주소 공간을 일정한 크기의 페이지로 분할 -> 주소 공간은 페이지 단위로 나뉘어져 있으며, 실제 메모리도 페이지 크기와 같은 프레임으로 나눈다. 페이지와 프레임은 동일 한 크기로 관리된다.
  - 프레임 (Frame) :  물리 메모리(RAM)를 일정한 크기로 나눈 블록
  - 페이지 (Page) :  가상 메모리를 일정한 크기로 나눈 블록
- 물리메모리(Frame)와 가상메모리(Page) 대응을 위해 page mapping 과정 필요 ->  페이지 테이블(Page mapping table) 설정
  - 페이지 테이블(page table) : 조각난 page와 frame을 매핑하고 실행될 수 있도록 연결 / 관리해주는 테이블
- 연속적이지 않은 공간을 활용할 수 있기 때문에 외부 단편화(External fragmentation) 해결할 수 있고 코드를 쉽게 공유할 수 있는 장점이 존재
  - 외부 단편화 (External fragmentation) : RAM에서 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간 중간 존재하게 되며, **사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태**를 보고 **메모리 단편화** 가 발생했다고 하며, 그 중에서도 외부 단편화는 **중간에 생긴 사용하지 않는 메모리가 많아서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황**을 말한다.
- 내부 단편화 문제는 여전히 존재한다.

![image](https://user-images.githubusercontent.com/46306263/97322451-2857fe00-18b3-11eb-9851-202a094f3d22.png)

<center>페이징 기법. 프로세스 B의 조각 다음 프로세스 A의 조각 배치 -> 굳이 연속적으로 배치할 필요가 없어짐 <br>( = 남는 공간이 생기지 않고, 외부 단편화가 발생하지 않음)</center>

<br>

##### 세그멘테이션(**Segmentation**) 기법

- 페이징 기법에선 가상 메모리를 같은 크기의 단위로 분할했지만, 세그멘테이션 기법에서는 가상 메모리를 **서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할해서 할당** -> 실제 메모리 주소로 변환
  - 각 세그멘트는 연속적인 공간에 저장
  - 세그먼트들의 크기는 각각 다르기 때문에 미리 분할할 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법
- 페이징 매핑 테이블과 마찬가지로 mapping을 위해 세그먼트 테이블이 필요
- 프로세스가 필요한 메모리만큼 할당하기 때문에 내부 단편화는 일어나지 않으나 **외부 단편화의 문제 존재**
  - 내부 단편화 (Internal fragmentatio) : 프로세스에 할당된 공간이 실제로 프로세스가 필요한(사용할) 공간보다 많이 할당되면 프로세스 내부에 쓰지 않는 공간이 발생하는데, 프로세스 내부에서 발생되는 단편화라고 해서 내부 단편화라고 한다. 

![](https://lh3.googleusercontent.com/proxy/84s5RfvMh9pdJ8Za-GTk26G4JNJ6wc3-GphVlWO2g3_FvP_e1RGIrt8GcnT7N6-xySrLgXBsVOOe6-A0mzxghKnzngI7CU-cE0L-hjfzFfc2lSir3gIZurEAhaMZTHT3dKaa3A4VM0NTHYz2gOWqefGwBFod)

<center>세그멘테이션 기법. 세그멘트의 가상 주소는 v = (s, d) 로 표시하며 s는 세그먼트 번호, d는 블록 내 세그먼트 위치를 뜻함<br> => 세그먼트 번호 3, 위치 250에 접근하여 3번 세그먼트의 시작 물리 주소(base)와 세그먼트 길이(limit)을 알아내 메모리 영역에 접근한다 </center>

<br><br>

#### 페이징 기법과 세그멘테이션 기법의 차이

![](https://user-images.githubusercontent.com/69128652/96007878-e9b95100-0e79-11eb-9691-953fb50deb5a.png)

<center>페이징 기법과 세그멘테이션 기법의 차이점</center>



<br><br>



### 참조자료

> - [메모리 관리 기법과 세그멘테이션, Segmentation 그리고 세그먼트](https://softwareji.tistory.com/76)
> - [[운영체제 OS] 메모리 관리기법 - 페이징 (paging)이란? 내부 단편화(Internal Fragmentatoin) 에 대해 알아보자](https://jhnyang.tistory.com/290?category=815411)

<br><br><br>

## 프로세스(Process)

#### 프로세스란?

- OS로부터 메모리를 할당받아 동작하는 프로그램의 동작 단위. 컴퓨터에서 연속적으로 **실행되고 있는(실행 중인)** 컴퓨터 프로그램.
- **프로세스 내부에는 최소 하나의 스레드(thread)**를 가지고있는데, 실제로는 스레드(thread) 단위로 스케줄링을 한다.
- 각종 자원들을 요청하고 할당받을 수 있는 작업

<br><br>

#### 프로세스의 동시 실행

- **하나의 프로세서(CPU)**는 `한 순간`에 `하나`의 프로세스만 실행할 수 있다.
- 프로세스 동시에 여러개 실행될 수 있는 이유는 `운영체제`가 빠르게 CPU가 실행할 프로세스를 교체하고 있기 때문. ( = 속도가 빠르기 때문에 사람은 동시에 여러개의 프로세스가 실행되고 있다고 느끼는 것)

<br><br>

#### 프로세스 상태

- 운영체제는 프로세스들의 실행 사이에 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 관리 필요
- 이를 위해 운영체제는 프로세스의 상태를 `준비`(ready), `실행`(running), `블록`(block) 상태로 분류
  - 생성(create): 프로세스 생성
  - 실행(running): 프로세스가 CPU를 차지하여 명령어들이 실행
  - 준비(ready): 프로세스가 CPU를 사용하고 있지는 않지만, 언제든지 사용할 수 있는 상태. CPU가 할당되기를 기다리고 있다. 일반적으로 준비상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당 받음.
  - 대기(waiting): 보류(block)라고 부르기도 한다. 프로세스가 I/O 나 시그널 수신 등을 기다리고 있는 상태.
  - 종료(terminated): 프로세스의 실행 종료
- 프로세스들을 `상태전이`(state transition)를 통해 체계적으로 관리

<br><Br>

#### 프로세스의 상태 전이

![](https://camo.githubusercontent.com/95bbb06a6a858c8b7bd211087841bb5591cac579/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323737333344343835364545414346363136)

<center>프로세스 상태 전이</center>

1. **준비(ready)** : 하나의 프로그램 실행 시, 그 프로그램에 대응되는 프로세스가 생성되어 준비 리스트의 끝에 들어감.
2. **실행(running)** : 점차 준비 리스트의 앞으로 나가게 되고, 언젠가 CPU를 사용할 수 있게 됨. -> 프로세스가 실행(Running) 상태로 변경
   - 디스패치(dispatch): 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것. **디스패처(dispatcher)가 이 일을 수행** ( 준비 상태에서 실행 상태로 바뀌는 것)
   - 보류(block): 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 I/O 동작을 필요로 하는 경우, 프로세스는 CPU를 반납하고 보류상태로 넘어가게 되는 현상.
3. **실행 > 블록(blocked)** : 현재 running 상태에 있는 프로세스A에서 입출력(I/O) 이벤트가 발생했을때 프로세스A가 blocked 상태로 감
4. **준비** : 입출력(I/O) 이벤트가 종료된 프로세스는 다시 준비(Ready) 상태로 오게 됨

> **ready, blocked 상태에는 여러 프로세스가 존재** 가능
>
> 하지만, **싱글코어CPU에서, running 상태의 프로세스는 단 하나**만 존재

<br><br>

#### 프로세스 큐(Queue)

- 프로세스가 여러개의 작업을 진행할 때, 순서를 대기하는 곳.
- 준비 큐, 대기 큐, 실행 큐 등의 자료 구조가 있다.
- 각 큐 내부에 저장된 실제 데이터에는 각 프로세스의 PCB(프로세스 블럭: Process Control Block)가 저장되어있다. 순서를 정해주는 알고리즘이 있는데, 이를 스케줄링이라고함.

<br><br>

#### 프로세스 제어 블럭 (PCB; Process Control Block)

- 프로세스 블럭, 프로세스 제어 블럭, 작업제어 블록(TCB:Task Control Block)으로 불림
- 프로세스가 생성될 때 같이 생성되며 프로세스에 대한 정보가 저장된다.
- 프로세스가 실행을 종료하면 PCB도 삭제한다

| 정보                                          | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| 프로세스 식별자 (PID; Process Identification) | 운영체제에서 프로세스 구분을 위한 각 프로세스의 고유 식별번호(식별자) |
| 프로세스 상태 (Process State)                 | CPU는 프로세스를 빠르게 교체하기 때문에 프로세스의 상태가 현재 어떤 상태인지 저장<br/> (생성,준비, 실행, 종료, 대기 상태) |
| 프로그램 카운터 (PC; Program Counter)         | 현재 프로세스가 다음에 실행할 명령어의 주소값을 가리킴       |
| CPU 레지스터 집합 (CPU 레지스터)              | 프로스세가 사용중인 레지스터. 컴퓨터 구조에 따라서 다양한 수와 타입을 가진다. <br>레지스터에는 누산기(accumulator), 인덱스 레지스터(index register), 스택 포인터(stack pointer), 범용 레지스터(general purpose registers) 등.<br>인터럽트가 발생하면 프로그램 카운터와 함께 저장하여 재실행할 때 원래대로 복귀할 수 있게 한다. |
| 프로세서 스케줄링 정보                        | CPU에서 프로세스의 우선순위, 스케줄링 큐의 포인터, 기타 스케줄 매개변수 계정정보 등 어떤 프로세스를 먼저 처리할지에 대한 중요한 요소. |
| 계정정보                                      | 프로세서 사용 시간, 실제 사용시간, 사용 상한 시간, 계정 번호, 작업이나 프로세스 번호 등 |
| 입출력 상태 정보<br>메모리 관리 정보<br>...   | 특별한 입출력 요구 프로세스에 할당된 입출력장치, 열린 파일 리스트 등<br>운영체제가 사용하는 메모리 시스템에 따른 상한,하한 레지스터(경계 레지스터), 페이지 테이블이나 세그먼트 테이블 값 등 |

<br><br>

#### 프로세스 간 통신 (IPC; Inter-Process Communication)

- 프로세스는 완전히 독립된 실행 객체이기 때문에 서로 다른 프로세스의 영향을 받지 않지만, 그만큼 서로 통신이 어려움
- 이를 위해 커널 영역에서 IPC 를 제공함 -> 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스 간 통신이 가능
- 커널에서 IPC를 위한 도구를 제공하며, 시스템 콜의 형태로 프로세스에게 제공된다

<br><br>

#### 통신 목적

- 정보 공유 (Information sharing)
  - 여러 사용자가 동일한 정보를 원할 수 있기 때문에 그런 정보를 병행적으로 접근할 수 있는 환경 구성 ( = 공유 파일 등)
- 모듈성 (Modularity)
  - 특정 시스템의 기능을 별도의 프로세스나 스레드로 구분하여 모듈식 형태의 시스템 구성. 각 시스템 모듈이 서로 협력하게 만들기 위함.
- 계산 가속화 (Computation speedup)
  - 특정 작업을 빨리 실행하고자 한다면, 해당 작업을 여러 개의 서브태스크(sub-task)로 나누어서 각각 다른 서브태스크들과 병렬로 실행되게 함.
  - 계산 가속화는 여러 개의 처리요소(processing element - CPU나 입출력 채널 등)들을 가진 경우에만 달성할 수 있음
- 편의성 (Convenience)
  - 개별 사용자들이 동시에 작업할 여러 태스크를 가짐 (= 한 사용자가 편집, 인쇄, 컴파일 등을 병렬로 실행)

<br><br>

#### 대표적인 통신 방법

##### PIPE

- 프로세스는 메모리공간을 복제하기 때문에, 통신을 하기 위해서 별도의 메모리 공간 할당 필요 -> PIPE 기술 등장

- 통신을 위한 메모리공간(버퍼)을 생성하여 프로세스가 데이터를 주고받게 끔 함

- **외부 프로세스와의 통신에도 사용이 가능**하지만 **단방향의 통신**이라는 단점이 존재 ( = 하나의 파이프를 사용하여 생성하면 데이터의 중복 등의 문제 발생)

- 익명 파이프와 네임드 파이프로 구분

  - 익명 파이프(Anonymous Pipe) : **외부 프로세스에서는 사용할 수 없는 파이프.** 부모 프로세스가 자식 프로세스를 생성하는 경우에만 가능 ( = 제한적인 사용)
  - 네임드 파이프(Named Pipe) : **외부 프로세스와 통신을 하기 위해서** 만들어짐. 각 파이프에 이름과 권한을 부여하여 파이프를 생성함으로 부모 프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신 가능. 읽기/쓰기 모두 가능하지만 한 번에 한 방향으로만 통신 가능한 **반 이증 통신(Half-Duplex)**

  ![](https://t1.daumcdn.net/cfile/tistory/99EB1A3359FC7EF536)

  <br><br>

##### **Message Queue**

- Queue(큐)는 선입선출(FIFO)의 자료구조를 가지는 통신설비로 커널에서 관리.

- 메모리를 사용한 PIPE로, 구조체 기반으로 메시지 단위의 통신을 한다.

- **메시지 큐에 쓸 데이터에 번호를** **붙임**으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있음

  ![img](https://blog.kakaocdn.net/dn/81Rcq/btqxkW6f8Bk/pr5TH0O6VziQoGI7nw9450/img.png)

<br><br>

##### 공유 메모리 (Shared Memory)

- PIPE, Named PIPE, Message Queue가 통신을 이용한 설비라면, Shared Memory는 공유메모리가 **데이터 자체를 공유**하도록 지원하는 설비
- 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용
- 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 다른 프로세스들과 공유할 수 있는 특수한 메모리 공간을 할당 -> 이후 어떤 프로세스건 해당 메모리영역에 접근 가능 (프로세스 A가 메세지를 공유 메모리에 전송 -> 프로세스 B가 공유 메세지를 읽음)
- 공유 메모리는 중개자가 없이 곧바로 메모리에 접근할 수 있기 때문에 다른 모든 IPC들 중에서 가장 빠르게 작동하지만 보안적인 측면에서 취약

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F995C864E5B9766171D9786)

<br><br>

##### 소켓(Socket)

- 네트워크 소켓 통신을 시용해 네트워크 상에서 프로세스 간에 데이터 공유 ( Client - Server 구조로 데이터 통신)
- Local 뿐만 아니라, Remote 통신이 가능 
- 가장 큰 장점은 네트워크 통신에 사용하던 기술을 그대로 사용할 수 있다는 점. ( = 코딩의 일관성 유지)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzrukZ%2FbtqxhKTsuLh%2F1QRBp2bT785JXGcaZgQY8k%2Fimg.png)



<br><br>

#### 프로세스와 스레드의 차이

- 프로세스 (Process) : 메모리에 적재(load) 되어 실행되고 있는 프로그램. 정적인 프로그램과 달리 실행 중인 프로그램이기 때문에 **동적** . 생성되면서 메모리 공간 등을 복사하여 자원을 할당. **한 프로그램에서 실행되는 여러 프로세스가 동시에 존재할 수 있다.** (ex 윈도우 유저가 메모장 여러개를 실행할 수 있음)
- 스레드 (Thread) :  최소의 프로세스 동작 단위. 프로세스 내에서 실행되는 각각의 일. 기본적으로 하나의 프로세스가 생성되면 하나의 스레드가 같이 생성되며, 이를 **메인 스레드**라고 함. 일반적으로 1 프로세스 1 스레드 (여러 개의 스레드를 가질 수 있다 -> 멀티 스레드)

| Process                        | **Thread**                      |                                                              |
| ------------------------------ | ------------------------------- | ------------------------------------------------------------ |
| 정의                           | 실행 중인 프로그램              | 경량화된 프로세스 ( = 프로세스의 실행 단위)                  |
| 생성 / 종료 시간               | 많은 시간 소모                  | 적은 시간 소요                                               |
| 컨텍스트 전환 (context switch) | 많은 시간 소요                  | 적은 시간 소요                                               |
| 독립성                         | 각각의 Memory space를 차지한다. | 프로세스 안에서 동작하며 Code, Data, Heap 영역을 공유하고 별도의 Stack만 가지고 있다. |

<br><br>

#### 컨텍스트 전환 (context switch)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F994590345BB1B4DB2F7E5C)

1. 프로세스 P0와 P1이 존재할 때, P0가 CPU를 점유중(excuting)이었고 P1이 대기중(idle) 상태 -> P1이 실행이 되고 P0가 대기가 되는 상태가 됨 
2. 이때 P0가 실행중에서 대기로 변하게 될 때는 지금까지 작업해오던 내용을 모두 어딘가에 저장해야하는데 그것이 PCB 
3. P0는 PCB에 저장해야하고 P1이 가지고 있던 데이터는 PCB에서 가져와야한다. 
4. P0와 P1이 서로 **대기<->실행을 번갈아가며 하는 것을 `컨텍스트 스위칭(컨텍스트 전환, context switch )`**

- CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장 및 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업
- 컨텍스트 스위칭을 통해 멀티 프로세싱, 멀티 스레딩 운영 가능 
- 위 이미지에서 P0가 Excute에서 idle이 될 때 P1이 바로 Excute가 되지 않고 idle을 좀 더 하다가 Excute가 됨 -> **P0 상태를 PCB에 저장하고 P1 상태를 PCB에서 가져와야 하기 때문**
  - PCB를 저장하고 가져올때는 CPU가 아무런 일도 하지 못 함 -> 컨텍스트 스위칭이 너무 잦으면 오버헤드가 발생하여(비용이 높아) 성능 하락

<br><br>

#### 멀티 스레드(Multi-threading)와 멀티 프로세싱(multi-process)

|          |                 멀티 프로세싱(multi-process)                 |                 멀티 스레딩(Multi-threading)                 |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 기본<br> | 여러 개의 프로세서가 작업을 병렬적으로 처리<br>프로세스가 하나의 작업을 전담하는 것이 아니라, 여러개의 프로세스가 하나의 작업일 때도 협력적으로 처리 | 단일 프로세스의 다중 스레드를 만들어 여러 개의 스레드끼리 자원을 공유하는 것<br>각 스레드로 하여금 작업을 처리 |
|   실행   |                  여러 프로세스가 동시 실행                   |           단일 프로세스의 여러 스레드가 동시 실행            |
|   창조   |        프로세스 생성은 시간 소모적이며 리소스 집약적         |        스레드 생성은 감지 시간과 자원 모두에서 경제적        |
|   분류   |           다중 처리는 대칭 또는 비대칭 일 수 있음            |                     멀티 스레딩은 분류 X                     |
|   장점   | 단일 프로세싱을 이용할 때에 비해 비용 절감<br/>일부 프로세스에 문제가 발생해도 작업을 나눠 실행하기 때문에 영향이 확산되지 않음 ( = 신뢰성 증가) | 자원의 효율성 증대( = 시스템 자원 소모 감소)<br>시스템 처리 비용 감소<br>Stack 영역 제외 모든 메모리 공유로 통신 부담 감소 |
|   단점   | 컨텍트 스위칭 과정에서의 오버헤드 발생 가능성<br>복잡한 통신 기법(IPC) | 자원 공유 등 동기화 문제 발생 가능성<br>하나의 스레드에 문제 발생 시, 전체 프로세스 영향 |

<br><br><br>

## 스레드(Thred)와 동시성(Concurrency)

#### 스레드(thred)

- 프로세스 내에서 실행되는 흐름의 단위.
- 일반적으로 한 프로그램 당 하나의 스레드를 갖지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행 시킬 수 있는데, 이를 멀티 스레드 라고 한다.
- 스레드를 지원하는 주체에 따라, 사용자 레벨 스레드와 커널 레벨 스레드로 나뉜다.
  - 사용자 레벨 스레드:
    - 사용자 레벨의 라이브러리를 통해 구현. 라이브러리에서 스레드의 생성 및 스케줄링에 대한 관리 기능 제공.
    - 속도가 빠르지만, 하나의 시스템이라도 중단 될 경우, 전체 스레드가 중단된다.
  - 커널 레벨 스레드:
    - 운영체제가 지원하는 스레드 기능으로 구현. 커널이 스레드 생성 및 스케줄링에 대한 관리 기능 제공.
    - 속도가 사용자 스레드보다는 느리지만, 하나의 스레드가 종료되어도, 전체 스레드가 종료되지않고 실행된다.
- 스레드의 데이터에는 고유한스레드의 정보를 갖는 **기본 데이터**와, 멀티 스레드에서 개별 스레드만의 자료 공간이 필요할 경우 사용되는 **특정 데이터**가 있다.

<br><br>

#### 동시성(Concurrency)

- 병행성이라고도 한다.

- 동시성(병행성)은 2개 이상의 Task가 진행(making process)되고 있는 것이다.

- 운영체제가 프로세서 시간을 나눠, 여러 프로세스를 빠르게 전환하여 실행하는 방식. 싱글코어에서 멀티쓰레드를 동작시킨다.

- 논리적인 개념이며, 다중 프로그래밍 시스템에서 가질 수 있는 성질이다.

  <br><br>

#### 동시성(병행성)과 병렬성(Parallelism)

- 단순히 동시에 실행 되는 것 처럼 보이는 동시성과는 달리, 병렬성은 실제로 동시에 여러 작업이 처리 되는 것.
- 멀티 코어에서 멀티 스레드를 동작시키는 방식이다.
- 한 번에 많은 일을 처리하며, 물리적 개념을 가지고 있다.



![](https://camo.githubusercontent.com/2332c1e90dab90cb98eb4866dff4897dff70159c/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e253246635352614b6b253246627471775668714e6476342532464e324a544259723444474e315132456372764c65464b253246696d672e6a7067)



<center>동시성(concurrency) : 하나의 커피머신에서 커피를 받기 위해 두 줄로 서서 번갈아 가며 사용<br>병렬성(parallelism) : 두 개의 커피머신이 존재하며 각 머신마다 하나의 줄을 갖고 있어서 줄마다 사용 가능</center>

<br><br>

#### 레이스 컨디션 (Race Condition)

- 프로세스들이 동시에 자원을 사용하기 위해 경쟁하는 것.
- 같은 시스템이나 프로그램에서 동시에 실행하려 할 때 생기는 문제를 말한다. ( = CPU 우선권을 차지 하기 위한 경쟁)
  - 트랜잭션(Transaction)은 더 이상 나눌 수 없는 업무 처리의 단위. (더 이상 나눌 수 없다 = 원자성을 보장해야 한다)
  - **원자성(Atomicity)**은 특정 **실행 컨텍스트(Context)**에서 더 이상 나눌 수 없는 연산을 의미. 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. (Ex: 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것)
- Race Condition Attack : 경쟁하는 프로세스들을 이용해서 관리자 권한을 얻는 공격 방법

<br><Br>

#### **비동기(Asynchronous) 프로그래밍**

- 프로그램의 주 실행 흐름을 멈추어서 기다리는 부분 없이 바로 다음 작업을 실행할 수 있게 하는 방식
- 코드의 실행 결과 처리를 별도의 공간에 맡겨둔 뒤 결과를 기다리지 않고 바로 다음 코드를 실행하는 병렬처리 방식

<br><br><br>

## 스케줄링(Scheduling)

#### 스케줄링이란?

- 다중 프로그래밍을 가능하게 하는 운영체제의 동작기법.
- 여러 프로세스가 있고, 이 프로세스들이 자원(CPU 등)을 동시에 요구하는데 자원은 제한 -> 제한된 자원들을 어떻게(순서를 할당하는 등) 나눠줄 것인지에 대한 정책
- 프로세스가 생성되어 완료될 때 까지 프로세스는 여러종류의 스케줄링 과정을 거치는데, 이 때의 스케줄링의 종류로는 장기 스케줄링, 중기 스케줄링, 단기 스케줄링이 있다.
  - 장기 스케줄링: 상위 스케줄링이라고 함. 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할것인가를 결정하여 준비상태 큐로 보냄.
  - 중기 스케줄링: 어떤 프로세스들이 CPU를 할당 받을 것인지 결정. 할당을 받으려는 프로세스가 많을 경우, 일시보류 -> 활성화 하여, 일시적으로 부하를 조절한다.
  - 단기 스케줄링: 프로세서 스케줄링, 하위 스케줄링이라고 함. 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업.

<br><br>

#### 스케줄링 방식

스케줄링에는 크게 **선점형(Preemptive) 스케줄링**과 **비선점형(Non-Preemptive) 스케줄링** 2가지 방식으로 나눈다.

- 선점형(Preemptive) 스케줄링
  - 프로세스가 CPU를 할당받아 실행 중이더라도 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 CPU를 강제로 빼앗을 수 있는 방식
  - CPU 처리 시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하지만 잦은 스위칭으로 오버헤드가 많이 발생한다.
    - 오버헤드(overhead) : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등
- 비선점형(Non-Preemptive) 스케줄링
  - 선점형과 반대로 프로세스가 CPU를 점유하고 있다면 다른 프로세스가 CPU를 빼앗을 수 없는 방식.
  -  프로세스가 CPU를 점유하고 있을 때 I/O나 인터럽트가 발생하거나 프로세스가 종료될 때까지 다른 프로세스가 점유할 수 없음
  - 플요한 스위칭만 일어나기 때문에 오버헤드가 상대적으로 적다. 하지만 프로세스 배치에 따라 효율성 차이가 큼

<br><Br>

#### 스케줄링 종류 

- **First-Come, First-Served (FCFS)**
  - FCFS(First Come First Served) = FIFO(First in First Out)
  - 준비상태 큐에 따라 도착한 순서대로 CPU를 할당하는 기법으로 **비선점형(Non-Preemptive) 스케줄링**
  - 공평성은 유지할 수 있지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을  기다릴 수 있음.
- **Shortest-Job-First (SJF)**
  - 가장 짧은 프로세스가 가장 먼저 수행되는 방식
  - 선점형과 비선점형 방식 모두 가능하지만 비현실적.  
    - 프로세스의 CPU 점유 시간을 알 수 없을뿐더러 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수밖에 없다. (= 큰 오버헤드를 발생 -> 잘 사용되지 않음)
- **SRT(Shortest Remaining Time) 스케줄링**
  - **선점형 스케줄링**. SJF 기법을 선점형으로 변형한 기법으로 선점 SJF 라고도 불림
  - 현재 실행 중인 프로세스의 남은 시간과 준비 상태 큐에 있는 프로세스의 실행 기간과 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에 CPU를 할당하는 방식.
- **HRN(Highest Response Ratio Next) 스케줄링**
  - SJF 기법의 약점인 긴 작업과 짧은 작업의 지나친 불평등을 보완한 기법
  - **비선점형 스케줄링**. 실행시간이 짧거나 대기시간이 긴 프로세스가 우선 순위가 높은 방식.
- **우선순위(Priority) 스케줄링**
  - **비선점 스케줄링**. 각 프로세스에 우선순위를 부여하여 우선순위가 높은 순서대로 처리하는 방식
  - 우선순위가 같으면 FCFS 방식으로 처리하며, 우선순위가 가장 낮을 경우에는 무한 연기상태( = 기아 상태)가 발생할 수 있다
- **기한부(Deadline) 스케줄링**
  - 프로세스에게 일정한 시간을 부여하고 그 시간 내로 프로세를 완료하도록 하는 기법. **비선점 스케줄링**
  - 주어진 시간 안에 완료되지 못 할 경우 제거 되거나 처음부터 다시 실행되기 때문에 손해가 큰  방식.
  - 작업 시간이나 상황 등 정보를 예측하기 어렵다는 단점도 존재
- **라운드 로빈(RR; Round-Robin) 스케줄링**
  - **선점 스케줄링**. 시간 할당량(Time Slice) 동안만 실행 -> 완료하지 못 했다면 다음 프로세스에게 CPU를 양보하고 준비상태 큐의 가장 마지막에 배치된다.
  - FCFS 기법을 선점 형태로 변형한 기법.  시스템이 사용자에게 적합한 응답시간을 제공해 주는 대화식 시분할 시스템에 적합.
  - 시간 할당량이 클 수록 FCFS와 동일하고, 작을 수록 오버헤드가 증가
- **다단계 피드백 큐(MQ; Multilevel Feedback Queue) 스케줄링**
  - 각 그룹별 준비상태 큐마다 시간 할당량을 부여하고 그 시간동안 완료하지 못한 프로세스는 다음 단계의 준비상태 큐로 이동하는 기법
  - **선점 스케줄링. 그룹별 준비상태 큐간 이동이 불가능한 다단계 큐 스케줄링의 변형
  - 상위 단계 준비상태 큐일수록 우선순위↑, 시간 할당량↓
  - 마지막 단계 큐에서는 Round Robin 스케줄링 기법 사용

<br><br>

<br>

## 기본적인 네트워크 개념

#### 네트워크(Network)란?

- Net+Work의 합성어. 하드웨어끼리 그물망처럼 연결되어 데이터를 주고 받는 **통신 이용 형태**. 주로 `통신망` 이라고 함.

<Br><br>

#### 프로토콜(Protocol)

- 본래 외교상의 용어. 네트워크를 통합하여 컴퓨터끼리 통신을 하는 데 있어, 상호간에 정해진 집합 통신 절차, 규약.
- 서로 언어(프로토콜)가 달라서 대화(통신)가 불가능 한 상황이 벌어질 수 있기 때문에, 어떤 언어를 쓰자는 약속이다.
- **세분화와 재합성, 캡슐화, 연결제어, 오류제어, 흐름제어, 동기화, 순서 결정, 주소 설정, 다중화, 전송 서비스** 의 기능을 가진다
- TCP/IP (Transmission Control Protocol / Internet Protocol)
  - 컴퓨터와 컴퓨터가 통신 회선 등으로 연결 하기 위한 통신 규약
- 종류로는 HTTP, ARP, ICMP, SNMP, SMTP, POP, FTP, TFTP, DHCP 등이 존재

<br><Br>

#### 네트워크의 구성요소

- 하드웨어적인 구성요소
  - **Network Interface Card (NIC)** = LAN 카드 (컴퓨터 메인보드 랜)
  - **Network Servers** = File Servers, Mail Servers, Printer Servers, DB Servers 등
  - **LAN 주변장치** = 프린터, 대용량 저장장치, 모뎀, 팩스
  - **LAN Workstation** = PC, UNIX 등 - 라우터, 스위치, 허브, 커뮤니케이션 서버, 파이어월
- 소프트웨어적인 구성요소
  - **Network Operating System** = Netware(IntraNetWare), Windows NT Server 등
  - **Communication Software** = TCP/IP Software , VPN 등
  - **LAN Applications**

<br><br>

#### 네트워크의 분류

네트워크의 분류는 **전송방식, 연결형태, 망의 규모, 통신 방법, 서비스 별**로 분류된다.

##### **전송 방식**

- 아날로그 통신망 : 음성이나 화상 등의 아날로그 정보를 핀폭, 위상, 주파수 형으로 전송하는 통신망
- 디지털 통신망 : 데이터 통신망과 상호 접속시켜 음성, 데이터 등 다양한 서비스를 제공할 수 있는 통신망

<br>

##### **연결 형태**

성형, 버스형, 링형, 트리형, 그물형, 혼합형이 존재

- 성(Star) 형

  - 중앙에 위치한 주 노드를 통하여 다른 노드들과 통신할 수 있는 네트워크 구조
  - 장애 발견이 쉽고, 관리가 용이하다는 장점이 있지만 주 노드에 장애가 발생할경우, 전체 네트워크 사용이 불가능

  [![성형](https://camo.githubusercontent.com/76d53e7bac3c4058280516597460adc9fd4f5ab8/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323631343543334335383134423634443138)](https://camo.githubusercontent.com/76d53e7bac3c4058280516597460adc9fd4f5ab8/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323631343543334335383134423634443138)

- 버스(Bus)형

  - 공유 통신 경로를 통해 연결된 클라이언트의 집합을 가리키는 네트워크 구조
  - 노드의 추가 및 삭제가 용이하며 특정 노드의 장애가 다른 노드에 영향을 주지 않음.
  - 공통 배선의 대역폭을 공유 -> 노드 수가 증가하면 배선의 트래픽이 증가하여 네트워크 성능 저하

  [![img](https://camo.githubusercontent.com/52b3776345e97096c86bacdb3a404324dc02e3cf/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134424230333935383134423537393241)](https://camo.githubusercontent.com/52b3776345e97096c86bacdb3a404324dc02e3cf/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134424230333935383134423537393241)

- 망(Mesh)형

  - 모든 노드가 서로 일대일로 연결된 그물망 형태로 다수의 노드 쌍이 동시 통신 가능

  - **완전 연결형**과 **부분 연결형**으로 분류

  - 하나의 노드에 장애가 발생해도 다른 노드에 영향을 주지 않으며 회선 장애에 유연한 대처가 가능

  - 새로운 노드 추가 시 추가적인 비용 부담 필요

    [![img](https://camo.githubusercontent.com/57e02807242593237d56d3c5168ecd32e898df64/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134394333333935383134423537423244)](https://camo.githubusercontent.com/57e02807242593237d56d3c5168ecd32e898df64/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134394333333935383134423537423244)

    [![img](https://camo.githubusercontent.com/9e2ea20cd7061c8af844cecb3d50b84c4fc6ed3c/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323534423730333935383134423537413241)](https://camo.githubusercontent.com/9e2ea20cd7061c8af844cecb3d50b84c4fc6ed3c/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323534423730333935383134423537413241)

<br>

##### 망의 규모

| 거리에 따른 분류          | 설명                                                         | 사용 범위                                                    |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| PAN Personal Area Network | 개인용 정보 단말기들 간에 정보를 주고받을 수 있도록 구성한 개인 영역 소규모 네트워크 | 2Km이내 ex) 기업, 캠퍼스 등                                  |
| LAN Local Area Network    | 제한된 지역에서 여러 대의 장치들을 서로 연결하는 독립적인 네트워크 | 10 ~ 50Km ex) 서울시 행정망, 대덕연구단지 망, 지역 케이블 방송망 등 |
| WAN Wide Area Network     | 서로 관련이 있는 LAN들을 상호 연결하는 광역 네트워크         | 1개 국가 ex) KT, DACOM 등의 서비스 망                        |

<br>

##### **통신 방법**

- 회선 교환망 (Circuit Swithcing Network)
  - 발신 기긱의 접속 정보(다이얼 숫자 등)로부터 교환기가 착신 기기까지의 회선 설정 후, 통신 정보를 송수신하는 통신 방식을 취하는 교환망
  - ex) 전화
- 패킷 교환망 (Packet Switching Network)
  - 정보의 송수신을 패킷 교환 방식으로 실현하는 교환망. (ex : 인터넷)
    - 패킷이란 데이터 전송에서 사용되는 데이터의 묶음
- 메시지 교환망 (Message Switching Nework)
  - 교환기가 일단 호출자의 전체 메시지를 받았다가 이를 적절한 경로를 통해 수신자에게 전달하는 교환망
  - 메시지 전달이 주목적이며, 빠른 응답을 요구하는 응용에는 부적합

<br>

##### **서비스 별**

- 부가가치 통신망 (VAN, Value Added Network)
  - 공중 통신 사업자로부터 회선을 대여받아 고도의 통신 처리 기능으로 부가 가치를 높여 서비스를 제공하는 통신망
- 종합정보통신망( IDSN, Integreated Services Digital Network)
  - 성격이 다른 서비스를 종합적으로 취급하는 디지털 통신망
- 공중망 (Public Network)
  - 통신 사업자나 통신 주관청이 제공하는 교환 접속형 통신망

<br><br>

#### 네트워크의 세분화 (OSI 7 Layer Model)

- Open System Interconnection 의 약자로, 개방형 시스템이라는 뜻
- OSI 참조 모델 ( = 컴퓨터나 네트워크 장치를 만들 때 OSI 참조 모델을 참고해서 통신장치를 만듦)
- OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것

##### Layer

- 기능적으로 비슷한 역할을 수행하는 protocol의 집합.
- 동일한 layer 안에 여러개의 protocol이 있을 수 있다.

<br>

##### Model

- 통신이 진행되는 순서에 따라 protocol layer를 배치한 것.
- 현재 사용되는 Model: OSI 77 Layer Model, TCP/IP Protocol Model

<br>

| 계층       | Layer                       | 기능                                                         | 프로토콜                   |
| ---------- | --------------------------- | ------------------------------------------------------------ | -------------------------- |
| 7계층 <br> | Application (응용)          | 네트워크 데이터를 만들기 위한 사용자 응용 프로그램.<br>응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행. | FTP, Telnet, http, smtp 등 |
| 6계층      | Presentation (표현)         | Application에서 만들어진 데이터를 독립화 시키고 네트워크에 보편적인 데이터로 전환 | XDR 등                     |
| 5계층      | Session<br>(세션)           | **데이터가 통신하기 위한 논리적인 연결**( = 통신을 위한 대문 역할)<br>Application간의 연결을 설정하거나 종료 시키고, 레이어 양단의 Application의 대화 교환, 종료를 담당함. | 인증, 세션설정 등          |
| 4계층      | Transport   (전송)          | 통신 활성화 위한 계층. 전송 될, 혹은 전송된 데이터의 품질을 보증하는 영역 전송계층에는 TCP와 UDP라는 통신수단이 존재<br> **TCP **: 신뢰성을 바탕으로 통신을 하는 방식. 데이터를 전송하는 과정에서 데이터의 누락이 발생시, 누락된 부분을 확인하여 다시 전달하는 통신 방식 <br>**UDP** : TCP와 다르게 비신뢰성을 바탕으로 통신. 데이터를 전송하는 과정에서 데이터의 누락 발생시, 누락된 부분을 확인않고, 바로 다음 데이터를 전송. | TCP, UDP                   |
| 3계층      | Network<br>(네트워크)       | **데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능 ( = 라우팅)**<br>네트워크 관리자가 직접 주소를 할당하는 구조. | IP, ICMP 등                |
| 2계층      | Data Link<br> (데이터 링크) | 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 **정보의 전달을 수행**할 수 있도록 도와주는 역할 | Ethernet(이더넷) 등        |
| 1계층      | Physical<br>(물리)          | 물리적 전송계층으로 네트워크 케이블,연결방식을 의미.<br>주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 테이블로 데이터를 전송 | 랜선, 허브                 |

<br>

##### **OSI 7 계층을 나눈 이유**

- 표준화를 통해서 다른 회사에서 만든 제품끼리도 통신이 될 수 있도록 하기위해서 (하드웨어 제조업체들의 공통의 플랫폼을 만들수 있음)

- 통신이 일어나는 과정이 단계별로 파악하여 흐름을 한 눈에 알아보고, 7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건들이지 않고도 이상이 생긴 단계만 고칠 수 있기 때문

  <br><br><br>



------------------

<br>

## 질문

1. **프로세스간 통신이 어떻게 이루어지는지**

   #### 프로세스간 통신(IPC; **Inter Process Communication**)

   - 프로세스는 독립된 실행객체로,  커널이 제공하는 IPC설비를 이용해서 프로세스간 통신을 할 수 있다.

   - 각각의 필요에 따라서 적당한 통신 설비들이 준비되어야 하는 것과 마찬가지로 내부 프로세스간 통신에도 그 상황에 맞는 IPC 설비를 선택할 필요가 있다. 잘못된 IPC 설비의 선택은 코딩과정을 어렵게 만들거나 프로그램의 작동을 효율적이지 못하게 만들 수 있기 때문.

   <br>

   #### IPC의 종류

    - **메시지 전달 (Message passing)**
      	- IPC를 위해 커널을 통해 메시지를 전달하는 방식으로 자원이나 데이터를 주고받는다. 
       - Direct Communication / Indirect Communication 이 있다.
         	- Direct Communication : 프로세스 A가 커널로 메시지를 보내면 커널이 프로세스 B에게 전달하는 방식.( **= 직접적**)
         	- Indirect Communication : 프로세스 A가 커널의 특정 메시지 박스에 메시지를 넣어두고 프로세스 B가 그 메시지 박스에서 메시지를 읽어오는 방식. ( **= 간접적**)
       - 별도로 다른 것을 구축할 필요 없이 커널을 이용하기 때문에 구현이 비교적 쉽고, OS가 동기화 해주기 때문에 안전하고 동기화 문제가 없다.
       - 커널을 이용하기 때문에, 시스템 콜(System call)이 필요하며 이로 인해 오버헤드가 발생한다.
      	- 종류로는 파이프, 시그널, 메시지 큐, 소켓 등이 있다.

   <br>

    - **공유 메모리 (Shared memory)**

      - IPC를 위해 공유 메모리 영역을 구축하고, 공유 영역을 통해 자원이나 데이터를 주고받는다.
      - 커널 의존성이 낮기 때문에 속도가 빠르다. 유저 레벨에서 IPC가 가능하기 때문에, 통신이 자유롭다.
      - 자원과 데이터를 공유하기 때문에 동기화 이슈( = 프로세스 A에서 넘긴 데이터나 자원이 맞는지 확인하는 기법이 추가적으로 필요)가 발생한다.

      <br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F997804425CC3DBE627E084){:.aligncenter}

<center>메시지 전달과 공유 메모리</center>









2. **스레드간 통신은 어떻게 이루어지는지**

   - 스레드는 프로세스 내에서 각각 스택(Stack) 만 따로 할당 받고, 코드(Code), 데이터(Data), 힙(Heap) 영역을 공유하기 때문에 프로세스 내 주소 공간이나 자원들을 같은 프로세스 내 스레드끼리 공유할 수 있다. 

     - 한 스레드가 프로세스 자원을 변경하면 다른 이웃 스레드도 그 변경 결과를 즉시 확인 가능

   - 스레드 간의 통신이 필요할 경우 별도의 자원을 이용하는 것이 아니라 전역 변수(데이터 세그먼트)의 공간을 이용하여 데이터를 주고 받을 수 있다.

   - 공유하는 전역 변수를 여러 스레드가 함께 사용할 때 충돌 문제가 발생할 수 있기 때문에 동기화 문제 발생 가능성이 있다.

     - 동기화(Synchronized) : 현재 작업 시 lock을 걸어 다른 스레드가 접근하지 못하게 하는 작업

     

